/*
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * Pipeline CD - RHDemo
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 *
 * Pipeline de D√©ploiement Continu (CD) pour l'application RHDemo
 *
 * OBJECTIF :
 *   - R√©cup√©rer une image Docker valid√©e depuis le registry
 *   - La d√©ployer sur l'environnement Kubernetes stagingkub
 *   - V√©rifier la sant√© de l'application d√©ploy√©e
 *
 * PR√â-REQUIS :
 *   - Image Docker publi√©e sur le registry par le pipeline CI (Jenkinsfile-CI)
 *   - Cluster KinD 'rhdemo' initialis√© (via init-stagingkub.sh)
 *   - Namespace 'rhdemo-stagingkub' cr√©√©
 *
 * R√âSULTAT :
 *   - Application RHDemo d√©ploy√©e sur stagingkub
 *   - Services accessibles via Ingress
 *   - Health checks valid√©s
 *
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

pipeline {
    agent any

    options {
        timeout(time: 30, unit: 'MINUTES')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '50', artifactNumToKeepStr: '10'))
    }

    tools {
        jdk 'JDK21'
        maven 'Maven3'
    }

    environment {
        // Configuration application
        APP_NAME = 'rhdemo-api'
        DOCKER_IMAGE_NAME = "rhdemo-api"

        // Kubernetes
        K8S_NAMESPACE = 'rhdemo-stagingkub'
        K8S_CONTEXT = 'kind-rhdemo'
        CLUSTER_NAME = 'rhdemo'

        // Fichiers de secrets SOPS (stagingkub utilise ses propres secrets, diff√©rents de staging Docker Compose)
        SECRETS_FILE = 'rhDemo/secrets/secrets-stagingkub.yml'
        SECRETS_DECRYPTED = 'rhDemo/secrets/secrets-decrypted.yml'
        SECRETS_ENV_VARS = 'rhDemo/secrets/env-vars.sh'
        SECRETS_RHDEMO = 'rhDemo/secrets/secrets-rhdemo.yml'

        // URLs
        APP_URL = 'https://rhdemo-stagingkub.intra.leuwen-lc.fr'
        KEYCLOAK_URL = 'https://keycloak-stagingkub.intra.leuwen-lc.fr'
    }

    parameters {
        string(
            name: 'IMAGE_TAG',
            defaultValue: '',
            description: 'Tag de l\'image √† d√©ployer (ex: 1.1.0-SNAPSHOT-95, 1.0.0-RELEASE). Si vide, r√©cup√®re automatiquement le digest du dernier build CI valid√© via Copy Artifact.'
        )
        string(
            name: 'CI_BUILD_NUMBER',
            defaultValue: '',
            description: 'Num√©ro du build CI √† utiliser (ex: 42). Si vide, utilise le dernier build stable du job RHDemo-CI.'
        )
        booleanParam(
            name: 'VERIFY_SIGNATURE',
            defaultValue: true,
            description: 'V√©rifier la signature Cosign de l\'image avant d√©ploiement'
        )
        booleanParam(
            name: 'FORCE_RECREATE_PODS',
            defaultValue: false,
            description: 'Forcer la recr√©ation des pods (rollout restart)'
        )
        booleanParam(
            name: 'SKIP_HEALTH_CHECK',
            defaultValue: false,
            description: 'Ne pas attendre les health checks (d√©ploiement plus rapide mais moins s√ªr)'
        )
    }

    stages {

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 1 : PR√âPARATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        stage('üõ†Ô∏è Checkout') {
            steps {
                script {
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "  Pipeline CD - RHDemo"
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "Build: #${env.BUILD_NUMBER}"
                    echo "Branch: ${env.GIT_BRANCH ?: 'N/A'}"
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                }

                // Checkout du code
                checkout scm
            }
        }

        stage('üî¢ D√©terminer Version Image') {
            steps {
                script {
                    if (params.IMAGE_TAG) {
                        // Utiliser le tag fourni en param√®tre
                        env.DEPLOY_IMAGE_TAG = params.IMAGE_TAG
                        env.DEPLOY_IMAGE_DIGEST = ''  // Sera r√©cup√©r√© plus tard si n√©cessaire
                        echo "‚ñ∂ Tag fourni en param√®tre: ${env.DEPLOY_IMAGE_TAG}"
                        echo "   Le digest sera r√©cup√©r√© depuis le registry lors de la v√©rification de signature"
                    } else {
                        // R√©cup√©rer le digest du dernier build CI valid√© via Copy Artifact
                        echo "‚ñ∂ Aucun tag fourni, r√©cup√©ration du digest depuis le dernier build CI valid√©..."

                        def ciBuildSelector
                        if (params.CI_BUILD_NUMBER) {
                            echo "   Build CI sp√©cifi√©: #${params.CI_BUILD_NUMBER}"
                            ciBuildSelector = specific(params.CI_BUILD_NUMBER)
                        } else {
                            echo "   Utilisation du dernier build CI stable"
                            ciBuildSelector = lastSuccessful()
                        }

                        // R√©cup√©rer les artefacts du build CI
                        copyArtifacts(
                            projectName: 'RHDemo-CI',
                            selector: ciBuildSelector,
                            filter: 'image-digest/*',
                            target: 'ci-artifacts',
                            fingerprintArtifacts: true
                        )

                        // Lire le tag et le digest depuis les artefacts
                        env.DEPLOY_IMAGE_TAG = readFile('ci-artifacts/image-digest/tag.txt').trim()
                        env.DEPLOY_IMAGE_DIGEST = readFile('ci-artifacts/image-digest/digest.txt').trim()
                        env.DEPLOY_IMAGE_REF = readFile('ci-artifacts/image-digest/image-ref.txt').trim()

                        echo "‚úÖ Informations r√©cup√©r√©es du build CI:"
                        echo "   Tag: ${env.DEPLOY_IMAGE_TAG}"
                        echo "   Digest: ${env.DEPLOY_IMAGE_DIGEST}"
                        echo "   Image ref: ${env.DEPLOY_IMAGE_REF}"
                    }

                    echo "‚úÖ Version de l'image √† d√©ployer: ${env.DEPLOY_IMAGE_TAG}"
                }
            }
        }

        stage('üîì D√©chiffrement Secrets SOPS') {
            steps {
                script {
                    echo '‚ñ∂ V√©rification SOPS et YQ...'
                }
                sh '''
                    sops --version
                    yq --version
                '''

                script {
                    echo '‚ñ∂ D√©chiffrement du fichier de secrets...'
                }

                // Utiliser le credential sops-age-key de mani√®re s√©curis√©e
                withCredentials([file(credentialsId: 'sops-age-key', variable: 'SOPS_AGE_KEY_FILE')]) {
                    sh '''
                        # Cr√©er le r√©pertoire secrets s'il n'existe pas
                        mkdir -p rhDemo/secrets

                        # D√©chiffrer le fichier de secrets
                        echo "D√©chiffrement de ${SECRETS_FILE}..."
                        sops -d ${SECRETS_FILE} > ${SECRETS_DECRYPTED}

                        # V√©rifier que le fichier a √©t√© d√©chiffr√©
                        if [ ! -f ${SECRETS_DECRYPTED} ]; then
                            echo "‚ùå √âchec du d√©chiffrement"
                            exit 1
                        fi

                        echo "‚úÖ Secrets d√©chiffr√©s avec succ√®s"

                        # Extraire les valeurs pour les variables d'environnement
                        # S√âCURIT√â: D√©sactiver l'√©cho des commandes pour ne pas exposer les secrets dans les logs
                        set +x

                        # Exporter les secrets comme variables d'environnement pour les stages suivants
                        {
                            # PROTECTION: D√©sactiver l'√©cho pour √©viter l'exposition des secrets lors du sourcing
                            echo "# S√âCURIT√â: Ce fichier contient des secrets - d√©sactive automatiquement le tracing bash"
                            echo "{ set +x; } 2>/dev/null"
                            echo ""

                            echo "export RHDEMO_DATASOURCE_PASSWORD_PG=$(yq eval '.rhdemo.datasource.password.pg' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_DATASOURCE_PASSWORD_H2=$(yq eval '.rhdemo.datasource.password.h2' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET=$(yq eval '.rhdemo.client.registration.keycloak.client.secret' ${SECRETS_DECRYPTED})"

                            # Mots de passe Keycloak pour environnement staging
                            echo "export KEYCLOAK_DB_PASSWORD=$(yq eval '.keycloak.db.password' ${SECRETS_DECRYPTED})"
                            echo "export KEYCLOAK_ADMIN_PASSWORD=$(yq eval '.keycloak.admin.password' ${SECRETS_DECRYPTED})"
                            echo "export KEYCLOAK_ADMIN_USER=$(yq eval '.keycloak.admin.user // \"admin\"' ${SECRETS_DECRYPTED})"
                        } > rhDemo/secrets/env-vars.sh 2>&1

                        # R√©activer l'√©cho des commandes
                        set -x

                        echo "‚úÖ Variables d'environnement pr√©par√©es"
                    '''
                }
            }
            post {
                always {
                    script {
                        // Supprimer le fichier d√©chiffr√© pour la s√©curit√©
                        sh 'rm -f ${SECRETS_DECRYPTED} || true'
                    }
                }
            }
        }

        stage('üîê Extraction secrets rhDemo') {
            steps {
                script {
                    echo '‚ñ∂ Cr√©ation du fichier secrets-rhdemo.yml pour rhDemo...'
                }

                sh '''
                    # S√âCURIT√â: D√©sactiver l'√©cho des commandes
                    set +x

                    # Source les secrets
                    . rhDemo/secrets/env-vars.sh

                    # Cr√©er le fichier secrets-rhdemo.yml
                    cat > rhDemo/secrets/secrets-rhdemo.yml <<EOF

rhdemo:
  datasource:
    password:
      pg: ${RHDEMO_DATASOURCE_PASSWORD_PG}
      h2: ${RHDEMO_DATASOURCE_PASSWORD_H2}
  client:
    registration:
      keycloak:
        client:
          secret: ${RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET}
EOF

                    # R√©activer l'√©cho
                    set -x

                    echo "‚úÖ Fichier secrets-rhdemo.yml cr√©√©"
                '''
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 2 : CONFIGURATION KUBERNETES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        stage('‚ò∏Ô∏è Configure Kubernetes Access') {
            steps {
                script {
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "  CONFIGURATION DE L'ACC√àS KUBERNETES"
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "‚ñ∂ Configuration de kubectl pour le cluster KinD..."
                }
                sh """
                    # Connecter Jenkins au r√©seau kind si n√©cessaire
                    JENKINS_CONTAINER=\$(hostname)
                    if ! docker network inspect kind 2>/dev/null | grep -q "\$JENKINS_CONTAINER"; then
                        echo "‚ñ∂ Connexion de Jenkins au r√©seau kind..."
                        docker network connect kind \$JENKINS_CONTAINER 2>/dev/null && echo "‚úÖ Jenkins connect√© au r√©seau kind" || echo "‚ö†Ô∏è  Impossible de connecter Jenkins au r√©seau kind"
                    else
                        echo "‚úÖ Jenkins d√©j√† connect√© au r√©seau kind"
                    fi

                    # Connecter le registry au r√©seau kind si n√©cessaire
                    echo "‚ñ∂ V√©rification de la connexion du registry au r√©seau kind..."
                    REGISTRY_CONTAINER=\$(docker ps --filter "publish=5000" --format '{{.Names}}' | head -n 1)
                    if [ -n "\$REGISTRY_CONTAINER" ]; then
                        # V√©rifier que le registry s'appelle bien 'kind-registry'
                        if [ "\$REGISTRY_CONTAINER" != "kind-registry" ]; then
                            echo "‚ùå ERREUR: Registry trouv√© '\$REGISTRY_CONTAINER' mais le nom attendu est 'kind-registry'"
                            echo ""
                            echo "   Cela indique une mauvaise manipulation ou une configuration incorrecte."
                            echo ""
                            echo "   Pour corriger:"
                            echo "   1. docker stop \$REGISTRY_CONTAINER && docker rm \$REGISTRY_CONTAINER"
                            echo "   2. cd rhDemo/infra/jenkins-docker && docker-compose up -d registry"
                            echo ""
                            echo "   Voir la documentation: rhDemo/docs/REGISTRY_SETUP.md"
                            exit 1
                        fi

                        # V√©rifier la connexion au r√©seau kind et l'alias
                        if ! docker network inspect kind 2>/dev/null | grep -q "\$REGISTRY_CONTAINER"; then
                            echo "‚ñ∂ Connexion du registry au r√©seau kind avec alias..."
                            docker network disconnect kind \$REGISTRY_CONTAINER 2>/dev/null || true
                            if docker network connect kind \$REGISTRY_CONTAINER --alias kind-registry 2>&1; then
                                REGISTRY_IP=\$(docker inspect \$REGISTRY_CONTAINER | jq -r '.[0].NetworkSettings.Networks.kind.IPAddress' 2>/dev/null || echo "N/A")
                                echo "‚úÖ Registry connect√© au r√©seau kind avec alias 'kind-registry' (IP: \$REGISTRY_IP)"
                            else
                                echo "‚ö†Ô∏è  Impossible de connecter le registry au r√©seau kind"
                            fi
                        else
                            # V√©rifier l'alias
                            if ! docker network inspect kind 2>/dev/null | grep -q '"kind-registry"'; then
                                echo "‚ö†Ô∏è  Registry connect√© mais alias 'kind-registry' manquant"
                                echo "‚ñ∂ Reconnexion avec alias..."
                                docker network disconnect kind \$REGISTRY_CONTAINER 2>/dev/null || true
                                docker network connect kind \$REGISTRY_CONTAINER --alias kind-registry
                                REGISTRY_IP=\$(docker inspect \$REGISTRY_CONTAINER | jq -r '.[0].NetworkSettings.Networks.kind.IPAddress' 2>/dev/null || echo "N/A")
                                echo "‚úÖ Registry reconnect√© avec alias 'kind-registry' (IP: \$REGISTRY_IP)"
                            else
                                REGISTRY_IP=\$(docker inspect \$REGISTRY_CONTAINER | jq -r '.[0].NetworkSettings.Networks.kind.IPAddress' 2>/dev/null || echo "N/A")
                                echo "‚úÖ Registry '\$REGISTRY_CONTAINER' d√©j√† connect√© au r√©seau kind avec alias 'kind-registry' (IP: \$REGISTRY_IP)"
                            fi
                        fi
                    else
                        echo "‚ö†Ô∏è  Aucun registry trouv√© sur le port 5000"
                        echo "   D√©marrez le registry avec: cd rhDemo/infra/jenkins-docker && docker-compose up -d registry"
                    fi

                    echo "‚úÖ R√©seau Docker configur√©"
                """

                // Installer le kubeconfig RBAC depuis le credential Jenkins
                script {
                    echo "‚ñ∂ Installation du kubeconfig RBAC..."
                    echo "   Le kubeconfig utilise le ServiceAccount 'jenkins-deployer'"
                    echo "   avec des permissions limit√©es au namespace ${env.K8S_NAMESPACE}"
                }

                withCredentials([file(credentialsId: 'kubeconfig-stagingkub', variable: 'KUBECONFIG_FILE')]) {
                    sh """
                        # Cr√©er le r√©pertoire .kube
                        mkdir -p \$HOME/.kube

                        # Copier le kubeconfig RBAC
                        cp "\$KUBECONFIG_FILE" \$HOME/.kube/config
                        chmod 600 \$HOME/.kube/config

                        echo "‚úÖ Kubeconfig RBAC install√©"

                        # V√©rifier l'acc√®s au cluster via les permissions RBAC
                        # Note: kubectl cluster-info n√©cessite un acc√®s √† kube-system
                        # que le ServiceAccount limit√© n'a pas (par design de s√©curit√©)
                        echo "‚ñ∂ V√©rification de l'acc√®s au cluster..."

                        # Afficher le contexte actuel
                        CURRENT_CONTEXT=\$(kubectl config current-context)
                        echo "   Contexte: \$CURRENT_CONTEXT"

                        # Tester les permissions sur le namespace cible
                        if kubectl auth can-i list pods --namespace ${env.K8S_NAMESPACE} > /dev/null 2>&1; then
                            echo "‚úÖ Acc√®s au cluster confirm√© (ServiceAccount RBAC)"

                            # V√©rifier l'acc√®s au namespace
                            if kubectl get namespace ${env.K8S_NAMESPACE} > /dev/null 2>&1; then
                                echo "‚úÖ Namespace '${env.K8S_NAMESPACE}' accessible"
                            else
                                echo "‚ö†Ô∏è  Namespace '${env.K8S_NAMESPACE}' non trouv√© (sera cr√©√© par Helm)"
                            fi

                            # V√©rifier les permissions cl√©s pour le d√©ploiement
                            echo "‚ñ∂ V√©rification des permissions RBAC..."
                            PERMS_OK=true

                            if kubectl auth can-i create deployments --namespace ${env.K8S_NAMESPACE} > /dev/null 2>&1; then
                                echo "   ‚úì Cr√©ation de deployments"
                            else
                                echo "   ‚úó Cr√©ation de deployments"
                                PERMS_OK=false
                            fi

                            if kubectl auth can-i create secrets --namespace ${env.K8S_NAMESPACE} > /dev/null 2>&1; then
                                echo "   ‚úì Cr√©ation de secrets"
                            else
                                echo "   ‚úó Cr√©ation de secrets"
                                PERMS_OK=false
                            fi

                            if kubectl auth can-i create persistentvolumes > /dev/null 2>&1; then
                                echo "   ‚úì Cr√©ation de PersistentVolumes"
                            else
                                echo "   ‚úó Cr√©ation de PersistentVolumes"
                                PERMS_OK=false
                            fi

                            # V√©rifier que ce n'est PAS un acc√®s admin (s√©curit√©)
                            if kubectl auth can-i get pods -n kube-system > /dev/null 2>&1; then
                                echo "‚ö†Ô∏è  ATTENTION: Acc√®s admin d√©tect√© - v√©rifiez la configuration RBAC"
                            else
                                echo "‚úÖ Isolation s√©curit√©: pas d'acc√®s aux namespaces syst√®me"
                            fi

                            if [ "\$PERMS_OK" = "false" ]; then
                                echo "‚ùå Permissions RBAC insuffisantes pour le d√©ploiement"
                                exit 1
                            fi
                        else
                            echo "‚ùå Impossible d'acc√©der au cluster KinD"
                            echo ""
                            echo "   Causes possibles:"
                            echo "   1. Le cluster KinD 'rhdemo' n'est pas d√©marr√©"
                            echo "   2. Le credential 'kubeconfig-stagingkub' est invalide ou expir√©"
                            echo "   3. Le ServiceAccount jenkins-deployer n'existe pas"
                            echo ""
                            echo "   Pour r√©g√©n√©rer le kubeconfig:"
                            echo "   cd rhDemo/infra/stagingkub/scripts && ./init-stagingkub.sh"
                            echo ""
                            echo "   D√©tails de l'erreur:"
                            kubectl auth can-i list pods --namespace ${env.K8S_NAMESPACE} 2>&1 || true
                            exit 1
                        fi
                    """
                }
            }
        }

        stage('üê≥ V√©rification Image Registry') {
            steps {
                script {
                    echo "‚ñ∂ V√©rification de l'image dans le registry..."
                }
                sh """
                    # D√©tection du registry sur le port 5000
                    REGISTRY_NAME=\$(docker ps --filter "publish=5000" --format '{{.Names}}' | head -n 1)

                    if [ -z "\$REGISTRY_NAME" ]; then
                        echo "‚ùå Aucun registry actif sur le port 5000"
                        exit 1
                    fi

                    echo "‚úÖ Registry d√©tect√©: \$REGISTRY_NAME"

                    # V√©rifier que l'image existe dans le registry (HTTPS avec certificat CA)
                    REGISTRY_URL="https://\$REGISTRY_NAME:5000"
                    REGISTRY_CERT="/etc/ssl/certs/registry.crt"

                    echo "‚ñ∂ V√©rification de l'image ${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG}..."

                    if curl -sf --cacert \$REGISTRY_CERT \$REGISTRY_URL/v2/${env.DOCKER_IMAGE_NAME}/tags/list | grep -q "${env.DEPLOY_IMAGE_TAG}"; then
                        echo "‚úÖ Image trouv√©e dans le registry"
                    else
                        echo "‚ùå Image ${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG} introuvable dans le registry"
                        echo ""
                        echo "   Tags disponibles pour ${env.DOCKER_IMAGE_NAME}:"
                        curl -s --cacert \$REGISTRY_CERT \$REGISTRY_URL/v2/${env.DOCKER_IMAGE_NAME}/tags/list || echo "   Aucun tag trouv√©"
                        echo ""
                        echo "   Ex√©cutez d'abord le pipeline CI pour construire et publier l'image"
                        exit 1
                    fi
                """
            }
        }

        stage('üîè V√©rification Signature Image (Cosign)') {
            when {
                expression { params.VERIFY_SIGNATURE == true }
            }
            steps {
                script {
                    echo "‚ñ∂ V√©rification de la signature de l'image avec Cosign..."
                    echo "   Image: kind-registry:5000/${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG}"
                    if (env.DEPLOY_IMAGE_DIGEST) {
                        echo "   Digest (depuis Copy Artifact): ${env.DEPLOY_IMAGE_DIGEST}"
                    }
                }

                withCredentials([file(credentialsId: 'cosign-public-key', variable: 'COSIGN_PUB_KEY')]) {
                    sh """
                        # Configuration du certificat CA pour HTTPS
                        REGISTRY_CERT="/etc/ssl/certs/registry.crt"

                        # Utiliser le digest fourni par Copy Artifact si disponible (plus s√©curis√©)
                        # Sinon, le r√©cup√©rer depuis le registry
                        if [ -n "${env.DEPLOY_IMAGE_DIGEST ?: ''}" ]; then
                            echo "‚ñ∂ Utilisation du digest fourni par le build CI (m√©thode s√©curis√©e)"
                            DIGEST="${env.DEPLOY_IMAGE_DIGEST}"
                        else
                            echo "‚ñ∂ R√©cup√©ration du digest depuis le registry (HTTPS)..."
                            DIGEST=\$(curl -sI --cacert \$REGISTRY_CERT -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \
                                https://kind-registry:5000/v2/${env.DOCKER_IMAGE_NAME}/manifests/${env.DEPLOY_IMAGE_TAG} \
                                | grep -i "Docker-Content-Digest" \
                                | awk '{print \$2}' \
                                | tr -d '\r')
                        fi

                        if [ -z "\$DIGEST" ]; then
                            echo "‚ùå Impossible de r√©cup√©rer le digest de l'image"
                            exit 1
                        fi

                        # Cosign utilise kind-registry:5000 (HTTPS direct depuis le conteneur Jenkins)
                        IMAGE_REF="kind-registry:5000/${env.DOCKER_IMAGE_NAME}@\$DIGEST"
                        echo "   Digest: \$DIGEST"
                        echo "   Image ref: \$IMAGE_REF"

                        # V√©rifier la signature avec Cosign (avec certificat CA)
                        echo "‚ñ∂ V√©rification de la signature..."
                        if SSL_CERT_FILE=\$REGISTRY_CERT cosign verify --key "\${COSIGN_PUB_KEY}" \
                            --insecure-ignore-tlog=true \
                            "\$IMAGE_REF" 2>&1; then
                            echo "‚úÖ Signature valide - l'image a √©t√© sign√©e par le pipeline CI"
                        else
                            echo "‚ùå ERREUR: Signature invalide ou absente !"
                            echo ""
                            echo "   L'image n'a pas √©t√© sign√©e par le pipeline CI ou la signature est corrompue."
                            echo "   Cela peut indiquer:"
                            echo "   - L'image a √©t√© pouss√©e manuellement sans signature"
                            echo "   - L'image a √©t√© modifi√©e apr√®s signature"
                            echo "   - Les cl√©s Cosign ne correspondent pas"
                            echo ""
                            echo "   Pour r√©soudre: relancez le pipeline CI pour reconstruire et signer l'image"
                            exit 1
                        fi
                    """
                }
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 3 : MISE √Ä JOUR DES SECRETS KUBERNETES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        stage('‚ò∏Ô∏è Update Kubernetes Secrets') {
            steps {
                script {
                    echo "‚ñ∂ Mise √† jour des secrets Kubernetes..."
                }
                sh """
                    # S√âCURIT√â: D√©sactiver l'√©cho des commandes pour ne pas exposer les secrets
                    set +x

                    # Charger les secrets depuis SOPS
                    . rhDemo/secrets/env-vars.sh

                    # Note: Le kubeconfig RBAC d√©finit d√©j√† current-context correctement

                    # Mettre √† jour les secrets Kubernetes
                    kubectl create secret generic rhdemo-db-secret \\
                      --from-literal=password="\${RHDEMO_DATASOURCE_PASSWORD_PG}" \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    kubectl create secret generic keycloak-db-secret \\
                      --from-literal=password="\${KEYCLOAK_DB_PASSWORD}" \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    kubectl create secret generic keycloak-admin-secret \\
                      --from-literal=password="\${KEYCLOAK_ADMIN_PASSWORD}" \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    # Mettre √† jour le secret pour secrets-rhdemo.yml
                    kubectl create secret generic rhdemo-app-secrets \\
                      --from-file=secrets-rhdemo.yml=rhDemo/secrets/secrets-rhdemo.yml \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    # R√©activer l'√©cho
                    set -x

                    echo "‚úÖ Secrets Kubernetes mis √† jour"
                """
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 4 : D√âPLOIEMENT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        stage('‚ò∏Ô∏è Deploy to Kubernetes') {
            steps {
                script {
                    def registryName = sh(script: 'docker ps --filter "publish=5000" --format "{{.Names}}" | head -n 1', returnStdout: true).trim()

                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "  D√âPLOIEMENT KUBERNETES (STAGINGKUB)"
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "‚ñ∂ D√©ploiement avec Helm..."
                    echo "   Chart: rhDemo/infra/stagingkub/helm/rhdemo"
                    echo "   Registry: ${registryName}"
                    echo "   Image: ${registryName}:5000/${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG}"
                    echo "   Namespace: ${env.K8S_NAMESPACE}"
                }
                sh """
                    # Note: Le kubeconfig RBAC d√©finit d√©j√† current-context correctement

                    # D√©terminer la politique de pull d'image
                    # Pour SNAPSHOT : Always (force le pull √† chaque d√©ploiement)
                    # Pour les releases : IfNotPresent (utilise le cache si disponible)
                    PULL_POLICY="IfNotPresent"
                    if echo "${env.DEPLOY_IMAGE_TAG}" | grep -qE "SNAPSHOT"; then
                        PULL_POLICY="Always"
                        echo "‚ö†Ô∏è  Tag SNAPSHOT d√©tect√© (${env.DEPLOY_IMAGE_TAG}) : imagePullPolicy=Always"
                        echo "   L'image sera toujours r√©cup√©r√©e du registry pour garantir la derni√®re version"
                    else
                        echo "‚ÑπÔ∏è  Version RELEASE fixe : imagePullPolicy=IfNotPresent"
                    fi

                    # D√©ployer ou mettre √† jour avec Helm
                    # IMPORTANT: Pour KinD, utiliser localhost:5000 qui est mirror√© vers le registry
                    # Note: --create-namespace cr√©e automatiquement le namespace s'il n'existe pas
                    echo "‚ñ∂ Lancement du d√©ploiement Helm..."
                    helm upgrade --install rhdemo rhDemo/infra/stagingkub/helm/rhdemo \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --create-namespace \\
                      --set rhdemo.image.repository=localhost:5000/${env.DOCKER_IMAGE_NAME} \\
                      --set rhdemo.image.tag=${env.DEPLOY_IMAGE_TAG} \\
                      --set rhdemo.image.pullPolicy=\${PULL_POLICY} \\
                      --wait \\
                      --timeout 15m \\
                      --debug

                    echo ""
                    echo "‚úÖ D√©ploiement Helm r√©ussi"

                    # CRITIQUE: Attendre explicitement que les pods rhdemo-app soient READY
                    # Cela permet √† l'Ingress Controller de synchroniser les endpoints actifs
                    # et √©vite les erreurs 503 lors des premiers acc√®s
                    echo ""
                    echo "‚ñ∂ Attente que les pods rhdemo-app soient compl√®tement ready..."
                    kubectl wait --for=condition=ready pod \\
                        -l app=rhdemo-app \\
                        -n ${env.K8S_NAMESPACE} \\
                        --timeout=300s

                    echo "‚úÖ Pods rhdemo-app ready - Ingress Controller peut maintenant router le trafic"
                """
            }
        }

        stage('üîÑ Force Pods Restart') {
            when {
                expression { params.FORCE_RECREATE_PODS == true }
            }
            steps {
                script {
                    echo "‚ñ∂ Red√©marrage forc√© des pods..."
                }
                sh """
                    # Note: Le kubeconfig RBAC d√©finit d√©j√† current-context correctement

                    # Rollout restart pour forcer le red√©marrage des pods
                    echo "   - Red√©marrage rhdemo-app..."
                    kubectl rollout restart deployment/rhdemo-app -n ${env.K8S_NAMESPACE}

                    echo "   - Red√©marrage keycloak..."
                    kubectl rollout restart deployment/keycloak -n ${env.K8S_NAMESPACE}

                    # Les StatefulSets PostgreSQL ne n√©cessitent pas de restart

                    echo "‚úÖ Rollout restart d√©clench√© - l'attente de la disponibilit√© se fera dans le stage suivant"
                """
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 5 : V√âRIFICATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        stage('‚ò∏Ô∏è Wait for Kubernetes Readiness') {
            when {
                expression { params.SKIP_HEALTH_CHECK == false }
            }
            steps {
                script {
                    echo "‚ñ∂ Attente de la disponibilit√© des services..."
                }
                sh """
                    # Note: Le kubeconfig RBAC d√©finit d√©j√† current-context correctement

                    # Attendre que tous les pods principaux soient pr√™ts
                    # Note: On attend les deployments/statefulsets plut√¥t que tous les pods
                    # pour √©viter d'attendre les pods en terminaison durant les rolling updates
                    echo "‚ñ∂ Attente des d√©ploiements..."

                    # Attendre les deployments
                    echo "   - Deployment rhdemo-app..."
                    kubectl rollout status deployment/rhdemo-app -n ${env.K8S_NAMESPACE} --timeout=10m || {
                        echo "‚ùå Deployment rhdemo-app non pr√™t"
                        kubectl get pods -n ${env.K8S_NAMESPACE} -l app=rhdemo-app
                        kubectl describe pod -n ${env.K8S_NAMESPACE} -l app=rhdemo-app | tail -50
                        exit 1
                    }

                    echo "   - Deployment keycloak..."
                    kubectl rollout status deployment/keycloak -n ${env.K8S_NAMESPACE} --timeout=10m || {
                        echo "‚ùå Deployment keycloak non pr√™t"
                        kubectl get pods -n ${env.K8S_NAMESPACE} -l app=keycloak
                        kubectl describe pod -n ${env.K8S_NAMESPACE} -l app=keycloak | tail -50
                        exit 1
                    }

                    # Attendre les StatefulSets PostgreSQL
                    echo "   - StatefulSet postgresql-rhdemo..."
                    kubectl wait --for=condition=Ready pod -l app=postgresql-rhdemo -n ${env.K8S_NAMESPACE} --timeout=5m || {
                        echo "‚ùå StatefulSet postgresql-rhdemo non pr√™t"
                        kubectl get statefulset postgresql-rhdemo -n ${env.K8S_NAMESPACE}
                        kubectl get pods -n ${env.K8S_NAMESPACE} -l app=postgresql-rhdemo
                        exit 1
                    }

                    echo "   - StatefulSet postgresql-keycloak..."
                    kubectl wait --for=condition=Ready pod -l app=postgresql-keycloak -n ${env.K8S_NAMESPACE} --timeout=5m || {
                        echo "‚ùå StatefulSet postgresql-keycloak non pr√™t"
                        kubectl get statefulset postgresql-keycloak -n ${env.K8S_NAMESPACE}
                        kubectl get pods -n ${env.K8S_NAMESPACE} -l app=postgresql-keycloak
                        exit 1
                    }

                    echo "‚úÖ Tous les d√©ploiements sont pr√™ts"
                    echo ""
                    echo "√âtat final des pods:"
                    kubectl get pods -n ${env.K8S_NAMESPACE}
                """
            }
        }

        stage('üè• Health Checks') {
            when {
                expression { params.SKIP_HEALTH_CHECK == false }
            }
            steps {
                script {
                    echo "‚ñ∂ V√©rification de la sant√© des services..."
                }
                sh """
                    # Note: Le kubeconfig RBAC d√©finit d√©j√† current-context correctement

                    echo "‚ñ∂ V√©rification de l'application RHDemo..."
                    # R√©cup√©rer le nom du pod rhdemo (label app=rhdemo-app)
                    RHDEMO_POD=\$(kubectl get pods -n ${env.K8S_NAMESPACE} -l app=rhdemo-app -o jsonpath='{.items[0].metadata.name}')

                    if [ -z "\$RHDEMO_POD" ]; then
                        echo "‚ùå Aucun pod rhdemo trouv√©"
                        kubectl get pods -n ${env.K8S_NAMESPACE} --show-labels
                        exit 1
                    fi

                    echo "   Pod: \$RHDEMO_POD"

                    # V√©rifier l'actuator health
                    if kubectl exec \$RHDEMO_POD -n ${env.K8S_NAMESPACE} -- curl -sf http://localhost:9000/actuator/health > /dev/null 2>&1; then
                        echo "‚úÖ Application RHDemo : healthy"
                    else
                        echo "‚ùå Application RHDemo : unhealthy"
                        echo "   Logs du pod:"
                        kubectl logs \$RHDEMO_POD -n ${env.K8S_NAMESPACE} --tail=50
                        exit 1
                    fi

                    echo ""
                    echo "‚ñ∂ V√©rification de Keycloak..."
                    KEYCLOAK_POD=\$(kubectl get pods -n ${env.K8S_NAMESPACE} -l app=keycloak -o jsonpath='{.items[0].metadata.name}')

                    if [ -z "\$KEYCLOAK_POD" ]; then
                        echo "‚ö†Ô∏è  Aucun pod Keycloak trouv√©"
                    else
                        echo "   Pod: \$KEYCLOAK_POD"

                        if kubectl exec \$KEYCLOAK_POD -n ${env.K8S_NAMESPACE} -- curl -sf http://localhost:9000/health/ready > /dev/null 2>&1; then
                            echo "‚úÖ Keycloak : ready"
                        else
                            echo "‚ö†Ô∏è  Keycloak : not ready"
                            kubectl logs \$KEYCLOAK_POD -n ${env.K8S_NAMESPACE} --tail=30 || true
                        fi
                    fi

                    echo ""
                    echo "‚ñ∂ V√©rification de PostgreSQL RHDemo (StatefulSet)..."
                    PG_RHDEMO_POD=\$(kubectl get pods -n ${env.K8S_NAMESPACE} -l app=postgresql-rhdemo -o jsonpath='{.items[0].metadata.name}')

                    if [ -z "\$PG_RHDEMO_POD" ]; then
                        echo "‚ö†Ô∏è  Aucun pod PostgreSQL RHDemo (primary) trouv√©"
                    else
                        echo "   Pod: \$PG_RHDEMO_POD"

                        if kubectl exec \$PG_RHDEMO_POD -n ${env.K8S_NAMESPACE} -- pg_isready -U rhdemo > /dev/null 2>&1; then
                            echo "‚úÖ PostgreSQL RHDemo : ready"
                        else
                            echo "‚ö†Ô∏è  PostgreSQL RHDemo : not ready"
                        fi
                    fi

                    echo ""
                    echo "‚úÖ Health checks termin√©s"
                """
            }
        }

        stage('üìä Deployment Status') {
            steps {
                script {
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "  √âTAT DU D√âPLOIEMENT"
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                }
                sh """
                    # Note: Le kubeconfig RBAC d√©finit d√©j√† current-context correctement

                    echo "üìä Statut des pods:"
                    kubectl get pods -n ${env.K8S_NAMESPACE} -o wide

                    echo ""
                    echo "üîó Services:"
                    kubectl get svc -n ${env.K8S_NAMESPACE}

                    echo ""
                    echo "üåê Gateway & HTTPRoutes:"
                    kubectl get gateway,httproute -n ${env.K8S_NAMESPACE}

                    echo ""
                    echo "üì¶ Images d√©ploy√©es:"
                    kubectl get pods -n ${env.K8S_NAMESPACE} -o jsonpath='{range .items[*]}{.metadata.name}{"\\t"}{.spec.containers[*].image}{"\\n"}{end}'

                    echo ""
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "‚úÖ D√âPLOIEMENT R√âUSSI"
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo ""
                    echo "üåç URLs d'acc√®s:"
                    echo "   Application: ${env.APP_URL}"
                    echo "   Keycloak: ${env.KEYCLOAK_URL}"
                    echo ""
                    echo "üìå Image d√©ploy√©e: ${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG}"
                    echo ""
                """
            }
        }

    } // fin stages

    post {
        always {
            script {
                echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                echo "Pipeline CD termin√©: ${currentBuild.currentResult}"
                echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

                // Supprimer les fichiers de secrets
                sh """
                    rm -f ${env.SECRETS_DECRYPTED} 2>/dev/null || true
                    rm -f ${env.SECRETS_ENV_VARS} 2>/dev/null || true
                    rm -f ${env.SECRETS_RHDEMO} 2>/dev/null || true
                
                    echo "‚úÖ Nettoyage termin√©"
                
                    #D√©connecter Jenkins du r√©seau Kind
                    docker network disconnect kind \$JENKINS_CONTAINER 2>/dev/null && echo "‚úÖ Jenkins d√©connect√© du r√©seau kind" || echo "‚ö†Ô∏è  Impossible de d√©connecter Jenkins du r√©seau kind"
                """
            }
        }
        success {
            script {
                echo "‚úÖ D√©ploiement r√©ussi !"
                echo ""
                echo "üìå Image d√©ploy√©e: ${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG}"
                echo "üåç Application accessible: ${env.APP_URL}"
                echo "üîë Keycloak accessible: ${env.KEYCLOAK_URL}"
                echo ""
                echo "Pour v√©rifier l'√©tat:"
                echo "   kubectl get pods -n ${env.K8S_NAMESPACE}"
                echo "   kubectl logs -f deployment/rhdemo -n ${env.K8S_NAMESPACE}"
            }
        }
        failure {
            script {
                echo "‚ùå D√©ploiement √©chou√© !"
                echo "Consultez les logs pour plus de d√©tails:"
                echo "   kubectl get pods -n ${env.K8S_NAMESPACE}"
                echo "   kubectl describe pods -n ${env.K8S_NAMESPACE}"
                echo "   kubectl logs -n ${env.K8S_NAMESPACE} <pod-name>"
            }
        }
    }
}
