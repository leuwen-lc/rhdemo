/*
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Pipeline CI - RHDemo
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Pipeline d'IntÃ©gration Continue (CI) pour l'application RHDemo
 *
 * OBJECTIF :
 *   - Compiler et construire l'application (Backend + Frontend)
 *   - ExÃ©cuter les tests unitaires et d'intÃ©gration
 *   - Analyser la qualitÃ© du code (SonarQube, OWASP)
 *   - CrÃ©er l'image Docker
 *   - Tester l'application dans un environnement staging Docker Compose
 *   - ExÃ©cuter les tests Selenium et OWASP ZAP
 *   - Publier l'image Docker validÃ©e sur le registry
 *
 * RÃ‰SULTAT :
 *   - Image Docker taggÃ©e et publiÃ©e : rhdemo-api:<VERSION>
 *   - Artifacts et rapports archivÃ©s
 *   - PrÃªte pour le dÃ©ploiement CD
 *
 * DÃ‰PLOIEMENT :
 *   - Pour dÃ©ployer sur Kubernetes stagingkub, utilisez le pipeline Jenkinsfile-CD
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

pipeline {
    agent any

    options {
        timeout(time: 2, unit: 'HOURS')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '30', artifactNumToKeepStr: '10'))
    }

    tools {
        jdk 'JDK21'
        maven 'Maven3'
    }

    environment {
        // Configuration application
        APP_NAME = 'rhdemo-api'
        DOCKER_IMAGE_NAME = "rhdemo-api"

        // Configuration Docker
        NGINX_IMAGE = "nginx:1.27-alpine"
        POSTGRES_IMAGE = "postgres:16-alpine"
        KEYCLOAK_IMAGE = "quay.io/keycloak/keycloak:26.4.2"

        // Configuration des tests
        TEST_PORT = '9000'
        TEST_PROJECT_PATH = 'rhDemoAPITestIHM'

        // Fichiers de secrets SOPS
        SECRETS_FILE = 'rhDemo/secrets/secrets-staging.yml'
        SECRETS_DECRYPTED = 'rhDemo/secrets/secrets-decrypted.yml'
        SECRETS_ENV_VARS = 'rhDemo/secrets/env-vars.sh'
        SECRETS_RHDEMO = 'rhDemo/secrets/secrets-rhdemo.yml'

        // Configuration environnement staging (Docker Compose)
        STAGING_INFRA_PATH = 'rhDemo/infra/staging'
        KEYCLOAK_INIT_PATH = 'rhDemoInitKeycloak'
        TEST_DOMAIN = 'rhdemo.staging.local'
        KEYCLOAK_DOMAIN = 'keycloak.staging.local'
        COMPOSE_PROJECT_NAME = "rhdemo-staging-${env.BUILD_NUMBER}"
        RHDEMO_IMAGE = "${DOCKER_IMAGE_NAME}:build-${env.BUILD_NUMBER}"

        // Noms des conteneurs Docker
        CONTAINER_NGINX = 'rhdemo-staging-nginx'
        CONTAINER_APP = 'rhdemo-staging-app'
        CONTAINER_KEYCLOAK = 'keycloak-staging'
        CONTAINER_KEYCLOAK_DB = 'keycloak-staging-db'
        CONTAINER_DB = 'rhdemo-staging-db'
        CONTAINER_ZAP = 'rhdemo-jenkins-zap'

        // Noms des rÃ©seaux Docker
        NETWORK_STAGING = 'rhdemo-staging-network'
        NETWORK_JENKINS = 'rhdemo-jenkins-network'
    }

    parameters {
        booleanParam(name: 'RUN_SELENIUM_TESTS', defaultValue: true, description: 'ExÃ©cuter les tests Selenium')
        booleanParam(name: 'RUN_SONAR', defaultValue: true, description: 'ExÃ©cuter l\'analyse SonarQube')
        booleanParam(name: 'PUBLISH_IMAGE', defaultValue: true, description: 'Publier l\'image sur le registry aprÃ¨s validation')
        string(name: 'IMAGE_TAG_SUFFIX', defaultValue: '', description: 'Suffixe optionnel pour le tag (ex: -rc1, -hotfix)')
    }

    stages {

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 1 : PRÃ‰PARATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸ› ï¸ Checkout') {
            steps {
                script {
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "  Pipeline CI - RHDemo"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "Build: #${env.BUILD_NUMBER}"
                    echo "Branch: ${env.GIT_BRANCH ?: 'N/A'}"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                }

                // Checkout du code
                checkout scm

                // Checkout du projet de tests IHM
                dir(env.TEST_PROJECT_PATH) {
                    git branch: 'main',
                        url: 'https://github.com/LenoBay/rhDemoAPITestIHM.git'
                }
            }
        }

        stage('ğŸ”¢ Lecture Version Maven') {
            steps {
                script {
                    echo "â–¶ Lecture de la version depuis pom.xml..."
                    def pomFile = readFile('rhDemo/pom.xml')
                    def project = new XmlSlurper().parseText(pomFile)
                    env.APP_VERSION = project.version.text()

                    if (!env.APP_VERSION) {
                        error("âŒ Impossible de lire la version depuis pom.xml")
                    }

                    echo "âœ… Version dÃ©tectÃ©e: ${env.APP_VERSION}"
                }
            }
        }

        stage('ğŸ”“ DÃ©chiffrement Secrets SOPS') {
            steps {
                script {
                    echo 'â–¶ VÃ©rification SOPS et YQ...'
                }
                sh '''
                    sops --version
                    yq --version
                '''

                script {
                    echo 'â–¶ DÃ©chiffrement du fichier de secrets...'
                }

                // Utiliser le credential sops-age-key de maniÃ¨re sÃ©curisÃ©e
                withCredentials([file(credentialsId: 'sops-age-key', variable: 'SOPS_AGE_KEY_FILE')]) {
                    sh '''
                        # CrÃ©er le rÃ©pertoire secrets s'il n'existe pas
                        mkdir -p rhDemo/secrets

                        # DÃ©chiffrer le fichier de secrets
                        echo "DÃ©chiffrement de ${SECRETS_FILE}..."
                        sops -d ${SECRETS_FILE} > ${SECRETS_DECRYPTED}

                        # VÃ©rifier que le fichier a Ã©tÃ© dÃ©chiffrÃ©
                        if [ ! -f ${SECRETS_DECRYPTED} ]; then
                            echo "âŒ Ã‰chec du dÃ©chiffrement"
                            exit 1
                        fi

                        echo "âœ… Secrets dÃ©chiffrÃ©s avec succÃ¨s"

                        # Extraire les valeurs pour les variables d'environnement
                        # SÃ‰CURITÃ‰: DÃ©sactiver l'Ã©cho des commandes pour ne pas exposer les secrets dans les logs
                        set +x

                        # Exporter les secrets comme variables d'environnement pour les stages suivants
                        # Utilisation de substitution de variables sans affichage dans stdout
                        {
                            # PROTECTION: DÃ©sactiver l'Ã©cho pour Ã©viter l'exposition des secrets lors du sourcing
                            echo "# SÃ‰CURITÃ‰: Ce fichier contient des secrets - dÃ©sactive automatiquement le tracing bash"
                            echo "# DÃ©sactiver le tracing pour ne pas logger les secrets"
                            echo "{ set +x; } 2>/dev/null"
                            echo ""

                            echo "export RHDEMO_DATASOURCE_PASSWORD_PG=$(yq eval '.rhdemo.datasource.password.pg' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_DATASOURCE_PASSWORD_H2=$(yq eval '.rhdemo.datasource.password.h2' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET=$(yq eval '.rhdemo.client.registration.keycloak.client.secret' ${SECRETS_DECRYPTED})"

                            # Mots de passe Keycloak pour environnement staging
                            echo "export KEYCLOAK_DB_PASSWORD=$(yq eval '.keycloak.db.password' ${SECRETS_DECRYPTED})"
                            echo "export KEYCLOAK_ADMIN_PASSWORD=$(yq eval '.keycloak.admin.password' ${SECRETS_DECRYPTED})"
                            echo "export KEYCLOAK_ADMIN_USER=$(yq eval '.keycloak.admin.user // \"admin\"' ${SECRETS_DECRYPTED})"

                            # Utilisateurs et mots de passe de test (chiffrÃ©s dans SOPS)
                            echo "export RHDEMO_TEST_ID_USER_ADMIN=$(yq eval '.rhdemo.test.iduseradmin' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_TEST_PWD_USER_ADMIN=$(yq eval '.rhdemo.test.pwduseradmin' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_TEST_ID_USER_MAJ=$(yq eval '.rhdemo.test.idusermaj' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_TEST_PWD_USER_MAJ=$(yq eval '.rhdemo.test.pwdusermaj' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_TEST_ID_USER_CONSULT=$(yq eval '.rhdemo.test.iduserconsult' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_TEST_PWD_USER_CONSULT=$(yq eval '.rhdemo.test.pwduserconsult' ${SECRETS_DECRYPTED})"

                            # URLs des serveurs si elles existent
                            if yq eval '.rhdemo.servers.staging' ${SECRETS_DECRYPTED} > /dev/null 2>&1; then
                                echo "export STAGING_SERVER=$(yq eval '.rhdemo.servers.staging' ${SECRETS_DECRYPTED})"
                            fi

                            if yq eval '.rhdemo.servers.production' ${SECRETS_DECRYPTED} > /dev/null 2>&1; then
                                echo "export PROD_SERVER=$(yq eval '.rhdemo.servers.production' ${SECRETS_DECRYPTED})"
                            fi
                        } > rhDemo/secrets/env-vars.sh 2>&1

                        # RÃ©activer l'Ã©cho des commandes
                        set -x

                        # Afficher (sans montrer les valeurs)
                        echo "âœ… Variables d'environnement prÃ©parÃ©es"
                    '''
                }
            }
            post {
                always {
                    script {
                        // Supprimer le fichier dÃ©chiffrÃ© pour la sÃ©curitÃ©
                        sh 'rm -f ${SECRETS_DECRYPTED} || true'
                    }
                }
            }
        }

        stage('ğŸ” Extraction secrets rhDemo') {
            steps {
                script {
                    echo 'â–¶ CrÃ©ation du fichier secrets-rhdemo.yml pour rhDemo (uniquement les secrets nÃ©cessaires)...'
                }

                sh '''
                    # SÃ‰CURITÃ‰: DÃ©sactiver l'Ã©cho des commandes
                    set +x

                    # Source les secrets
                    . rhDemo/secrets/env-vars.sh

                    # CrÃ©er un fichier secrets-rhdemo.yml contenant UNIQUEMENT les secrets rhDemo
                    # Ce fichier sera montÃ© dans le container Docker de rhDemo
                    cat > rhDemo/secrets/secrets-rhdemo.yml <<EOF

rhdemo:
  datasource:
    password:
      pg: ${RHDEMO_DATASOURCE_PASSWORD_PG}
      h2: ${RHDEMO_DATASOURCE_PASSWORD_H2}
  client:
    registration:
      keycloak:
        client:
          secret: ${RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET}
EOF

                    # RÃ©activer l'Ã©cho
                    set -x

                    echo "âœ… Fichier rhDemo/secrets/secrets-rhdemo.yml crÃ©Ã© (secrets limitÃ©s Ã  rhDemo uniquement)"
                '''
            }
        }

        stage('ğŸ”§ Configuration rhDemoInitKeycloak') {
            steps {
                script {
                    echo 'â–¶ GÃ©nÃ©ration de application-staging.yml pour rhDemoInitKeycloak...'
                    echo '   (Sera utilisÃ© directement via mvnw spring-boot:run, sans packaging JAR)'
                }

                sh '''
                    # SÃ‰CURITÃ‰: DÃ©sactiver l'Ã©cho des commandes pour ne pas exposer les secrets
                    set +x

                    # Source les secrets dÃ©chiffrÃ©s
                    . rhDemo/secrets/env-vars.sh

                    # GÃ©nÃ©rer application-staging.yml (sera utilisÃ© directement par Maven)
                    # NOTE: set +x reste actif pendant la gÃ©nÃ©ration pour ne pas logger les secrets
                    CONFIG_FILE="rhDemoInitKeycloak/src/main/resources/application-staging.yml"

                    # IMPORTANT: Sans guillemets sur YMLEOF pour que bash substitue les variables
                    cat > "${CONFIG_FILE}" << YMLEOF
# ========================================
# Configuration Keycloak Server - STAGING
# GÃ©nÃ©rÃ©e automatiquement par Jenkins CI/CD
# ========================================
keycloak:
  # URL interne HTTP pour rhDemoInitKeycloak (exÃ©cutÃ© dans le rÃ©seau Docker)
  # Pas besoin de HTTPS car communication interne sÃ©curisÃ©e par le rÃ©seau isolÃ©
  server-url: http://keycloak-staging:8080

  admin:
    realm: master
    username: ${KEYCLOAK_ADMIN_USER}
    password: ${KEYCLOAK_ADMIN_PASSWORD}

  # ========================================
  # Configuration du Realm RHDemo
  # ========================================
  realm:
    name: RHDemo
    display-name: RHDemo Application
    enabled: true
    registration-allowed: false
    registration-email-as-username: false
    reset-password-allowed: true
    edit-username-allowed: false
    login-with-email-allowed: true
    duplicate-emails-allowed: false
    remember-me: true
    sso-session-idle-timeout: 1800
    sso-session-max-lifespan: 36000
    access-token-lifespan: 300

  # ========================================
  # Configuration du Client RHDemo
  # ========================================
  client:
    client-id: RHDemo
    name: RHDemo
    secret: ${RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET}
    root-url: https://${TEST_DOMAIN}/
    base-url: ''
    admin-url: ''
    redirect-uris:
      - https://${TEST_DOMAIN}/*
      - http://localhost:9000/*
      - https://rhdemo.staging.local/*
      - https://keycloak.staging.local/*
    web-origins:
      - https://${TEST_DOMAIN}
      - http://localhost:9000
      - https://rhdemo.staging.local
      - https://keycloak.staging.local
    roles:
      - ROLE_admin
      - ROLE_consult
      - ROLE_MAJ

  # ========================================
  # Configuration des Utilisateurs de test
  # ========================================
  users:
    - username: ${RHDEMO_TEST_ID_USER_ADMIN}
      password: ${RHDEMO_TEST_PWD_USER_ADMIN}
      email: ${RHDEMO_TEST_ID_USER_ADMIN}@rhdemo.local
      first-name: Admin
      last-name: RHDemo
      roles:
        - ROLE_admin

    - username: ${RHDEMO_TEST_ID_USER_CONSULT}
      password: ${RHDEMO_TEST_PWD_USER_CONSULT}
      email: ${RHDEMO_TEST_ID_USER_CONSULT}@rhdemo.local
      first-name: Jean
      last-name: Consultant
      roles:
        - ROLE_consult

    - username: ${RHDEMO_TEST_ID_USER_MAJ}
      password: ${RHDEMO_TEST_PWD_USER_MAJ}
      email: ${RHDEMO_TEST_ID_USER_MAJ}@rhdemo.local
      first-name: Marie
      last-name: Manager
      roles:
        - ROLE_consult
        - ROLE_MAJ
YMLEOF

                    # RÃ©activer l'Ã©cho maintenant que les secrets ont Ã©tÃ© Ã©crits dans le fichier
                    set -x

                    echo "âœ… Fichier de configuration Keycloak gÃ©nÃ©rÃ©: ${CONFIG_FILE}"
                    echo "   Ce fichier sera utilisÃ© par rhDemoInitKeycloak pour initialiser Keycloak"
                '''
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 2 : BUILD ET TESTS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸ—ï¸ Compilation Maven') {
            steps {
                script {
                    echo "â–¶ Compilation du projet Maven..."
                }

                dir('rhDemo') {
                    sh './mvnw clean compile -DskipTests'
                }
            }
        }

        stage('âœ… Tests Unitaires') {
            steps {
                script {
                    echo "â–¶ ExÃ©cution des tests unitaires..."
                }

                dir('rhDemo') {
                    sh './mvnw test'
                }
            }
            post {
                always {
                    junit 'rhDemo/target/surefire-reports/*.xml'
                }
            }
        }

        stage('ğŸ” Analyse OWASP Dependency-Check') {
            steps {
                script {
                    echo "â–¶ Analyse des vulnÃ©rabilitÃ©s des dÃ©pendances..."
                }

                dir('rhDemo') {
                    sh './mvnw org.owasp:dependency-check-maven:check'
                }
            }
            post {
                always {
                    // Archiver le rapport OWASP
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'rhDemo/target',
                        reportFiles: 'dependency-check-report.html',
                        reportName: 'OWASP Dependency-Check Report'
                    ])
                }
            }
        }

        stage('ğŸ“¦ Build Maven') {
            steps {
                script {
                    echo "â–¶ Build du projet (crÃ©ation du JAR)..."
                }

                dir('rhDemo') {
                    sh './mvnw package -DskipTests'
                }
            }
        }

        stage('ğŸ“Š Analyse SonarQube') {
            when {
                expression { params.RUN_SONAR == true }
            }
            steps {
                script {
                    echo "â–¶ Analyse de la qualitÃ© du code avec SonarQube..."
                }

                withSonarQubeEnv('SonarQube') {
                    dir('rhDemo') {
                        sh './mvnw sonar:sonar'
                    }
                }
            }
        }

        stage('ğŸš¦ Quality Gate SonarQube') {
            when {
                expression { params.RUN_SONAR == true }
            }
            steps {
                script {
                    echo "â–¶ Attente du rÃ©sultat Quality Gate..."
                }

                timeout(time: 10, unit: 'MINUTES') {
                    waitForQualityGate abortPipeline: true
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 3 : DOCKER BUILD
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸ³ Build Image Docker') {
            steps {
                script {
                    echo "â–¶ Construction de l'image Docker..."
                    echo "   Image: ${env.RHDEMO_IMAGE}"
                }

                dir('rhDemo') {
                    sh """
                        docker build -t ${env.RHDEMO_IMAGE} .
                    """
                }

                script {
                    echo "âœ… Image Docker construite: ${env.RHDEMO_IMAGE}"
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 4 : DÃ‰PLOIEMENT STAGING DOCKER COMPOSE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸŒ PrÃ©paration RÃ©seau Docker') {
            steps {
                script {
                    echo "â–¶ CrÃ©ation des rÃ©seaux Docker pour staging..."
                }

                sh """
                    # CrÃ©er le rÃ©seau staging (isolÃ©)
                    docker network create ${env.NETWORK_STAGING} 2>/dev/null || echo "âœ“ RÃ©seau ${env.NETWORK_STAGING} existe dÃ©jÃ "

                    # CrÃ©er le rÃ©seau Jenkins (pour ZAP)
                    docker network create ${env.NETWORK_JENKINS} 2>/dev/null || echo "âœ“ RÃ©seau ${env.NETWORK_JENKINS} existe dÃ©jÃ "
                """
            }
        }

        stage('ğŸš€ DÃ©marrage Environnement Staging') {
            steps {
                script {
                    echo "â–¶ DÃ©marrage de l'environnement staging Docker Compose..."
                }

                dir(env.STAGING_INFRA_PATH) {
                    // Source les secrets
                    sh '''
                        set +x
                        . ../../secrets/env-vars.sh
                        set -x
                    '''

                    // DÃ©marrer Docker Compose
                    sh """
                        # Source les secrets
                        set +x
                        . ../../secrets/env-vars.sh

                        # Exporter les variables d'environnement nÃ©cessaires
                        export RHDEMO_IMAGE=${env.RHDEMO_IMAGE}
                        export KEYCLOAK_DB_PASSWORD=\${KEYCLOAK_DB_PASSWORD}
                        export KEYCLOAK_ADMIN=\${KEYCLOAK_ADMIN_USER}
                        export KEYCLOAK_ADMIN_PASSWORD=\${KEYCLOAK_ADMIN_PASSWORD}

                        set -x

                        # DÃ©marrer l'environnement
                        sudo docker compose -p ${env.COMPOSE_PROJECT_NAME} up -d

                        echo "âœ… Environnement staging dÃ©marrÃ©"
                    """
                }
            }
        }

        stage('â³ Attente Services Staging') {
            steps {
                script {
                    echo "â–¶ Attente du dÃ©marrage complet des services..."
                }

                sh """
                    echo "â–¶ Attente PostgreSQL..."
                    timeout 120 bash -c 'until docker exec ${env.CONTAINER_DB} pg_isready -U rhdemo > /dev/null 2>&1; do sleep 2; done'
                    echo "âœ“ PostgreSQL prÃªt"

                    echo "â–¶ Attente Keycloak DB..."
                    timeout 120 bash -c 'until docker exec ${env.CONTAINER_KEYCLOAK_DB} pg_isready -U keycloak > /dev/null 2>&1; do sleep 2; done'
                    echo "âœ“ Keycloak DB prÃªt"

                    echo "â–¶ Attente Keycloak (peut prendre 60-90s)..."
                    timeout 180 bash -c 'until curl -sf http://localhost:18080/health/ready > /dev/null 2>&1; do sleep 5; done'
                    echo "âœ“ Keycloak prÃªt"

                    echo "âœ… Tous les services sont prÃªts"
                """
            }
        }

        stage('ğŸ’¾ Initialisation Base de DonnÃ©es') {
            steps {
                script {
                    echo "â–¶ Initialisation de la base de donnÃ©es staging..."
                }

                dir(env.STAGING_INFRA_PATH) {
                    sh '''
                        echo "â–¶ VÃ©rification des fichiers SQL..."
                        PGSCHEMA_PATH="../../pgschema.sql"
                        PGDATA_PATH="../../pgdata.sql"

                        if [ ! -f "$PGSCHEMA_PATH" ]; then
                            echo "âŒ Erreur: Fichier pgschema.sql introuvable Ã  $PGSCHEMA_PATH"
                            exit 1
                        fi

                        if [ ! -f "$PGDATA_PATH" ]; then
                            echo "âŒ Erreur: Fichier pgdata.sql introuvable Ã  $PGDATA_PATH"
                            exit 1
                        fi

                        echo "âœ“ Fichiers SQL trouvÃ©s"

                        echo "â–¶ Copie des fichiers SQL dans le container..."
                        docker cp "$PGSCHEMA_PATH" rhdemo-staging-db:/tmp/schema.sql
                        docker cp "$PGDATA_PATH" rhdemo-staging-db:/tmp/data.sql

                        echo "â–¶ ExÃ©cution du schÃ©ma SQL..."
                        docker exec rhdemo-staging-db psql -U rhdemo -d rhdemo -f /tmp/schema.sql

                        echo "â–¶ Insertion des donnÃ©es de test..."
                        docker exec rhdemo-staging-db psql -U rhdemo -d rhdemo -f /tmp/data.sql

                        echo "â–¶ VÃ©rification..."
                        EMPLOYEE_COUNT=$(docker exec rhdemo-staging-db psql -U rhdemo -d rhdemo -t -c "SELECT COUNT(*) FROM employes;" | xargs)
                        echo "âœ… Base de donnÃ©es initialisÃ©e avec $EMPLOYEE_COUNT employÃ©s"
                    '''
                }
            }
        }

        stage('ğŸ”‘ Initialisation Keycloak') {
            steps {
                script {
                    echo "â–¶ Initialisation du realm et des utilisateurs Keycloak..."
                }

                dir(env.KEYCLOAK_INIT_PATH) {
                    sh '''
                        # Connecter rhDemoInitKeycloak au rÃ©seau staging
                        echo "â–¶ Connexion au rÃ©seau Docker staging..."

                        # ExÃ©cuter l'initialisation avec Maven
                        echo "â–¶ ExÃ©cution de rhDemoInitKeycloak..."
                        ../rhDemo/mvnw spring-boot:run -Dspring-boot.run.profiles=staging

                        echo "âœ… Keycloak initialisÃ© avec succÃ¨s"
                    '''
                }
            }
        }

        stage('ğŸ“‹ Copie Secrets vers Container App') {
            steps {
                script {
                    echo "â–¶ Copie du fichier de secrets dans le container applicatif..."
                }

                sh """
                    # CrÃ©er le rÃ©pertoire secrets dans le container
                    docker exec --user root ${env.CONTAINER_APP} mkdir -p /workspace/secrets

                    # Copier le fichier de secrets
                    docker cp ${env.SECRETS_RHDEMO} ${env.CONTAINER_APP}:/workspace/secrets/secrets-rhdemo.yml

                    # Corriger les permissions (user spring:spring depuis migration Dockerfile)
                    docker exec --user root ${env.CONTAINER_APP} chown spring:spring /workspace/secrets
                    docker exec --user root ${env.CONTAINER_APP} chown spring:spring /workspace/secrets/secrets-rhdemo.yml

                    echo "âœ… Secrets copiÃ©s dans le container"
                """
            }
        }

        stage('ğŸ”„ RedÃ©marrage Application') {
            steps {
                script {
                    echo "â–¶ RedÃ©marrage du container applicatif pour charger les secrets..."
                }

                sh """
                    docker restart ${env.CONTAINER_APP}

                    echo "â³ Attente du dÃ©marrage de l'application (actuator health)..."
                    timeout 180 bash -c 'until curl -sf http://localhost:${env.TEST_PORT}/actuator/health > /dev/null 2>&1; do sleep 5; echo -n "."; done'

                    echo ""
                    echo "âœ… Application dÃ©marrÃ©e et prÃªte"
                """
            }
        }

        stage('ğŸ”— Connexion NGINX au RÃ©seau Jenkins') {
            steps {
                script {
                    echo "â–¶ Connexion du container NGINX au rÃ©seau Jenkins (pour ZAP)..."
                }

                sh """
                    docker network connect ${env.NETWORK_JENKINS} ${env.CONTAINER_NGINX} 2>/dev/null || echo "âœ“ NGINX dÃ©jÃ  connectÃ© au rÃ©seau Jenkins"

                    echo "âœ… NGINX accessible depuis le rÃ©seau Jenkins"
                """
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 5 : TESTS SELENIUM ET OWASP ZAP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸ§ª Tests Selenium') {
            when {
                expression { params.RUN_SELENIUM_TESTS == true }
            }
            steps {
                script {
                    echo "â–¶ ExÃ©cution des tests Selenium..."
                }

                dir(env.TEST_PROJECT_PATH) {
                    sh '''
                        # Source les secrets pour les tests
                        set +x
                        . ../rhDemo/secrets/env-vars.sh

                        # Exporter les variables nÃ©cessaires pour Selenium
                        export SELENIUM_BASE_URL="https://${TEST_DOMAIN}"
                        export SELENIUM_ADMIN_USER="${RHDEMO_TEST_ID_USER_ADMIN}"
                        export SELENIUM_ADMIN_PASSWORD="${RHDEMO_TEST_PWD_USER_ADMIN}"
                        export SELENIUM_MAJ_USER="${RHDEMO_TEST_ID_USER_MAJ}"
                        export SELENIUM_MAJ_PASSWORD="${RHDEMO_TEST_PWD_USER_MAJ}"
                        export SELENIUM_CONSULT_USER="${RHDEMO_TEST_ID_USER_CONSULT}"
                        export SELENIUM_CONSULT_PASSWORD="${RHDEMO_TEST_PWD_USER_CONSULT}"

                        set -x

                        # ExÃ©cuter les tests Selenium
                        ../rhDemo/mvnw test -Dtest=RhDemoSeleniumTests
                    '''
                }
            }
            post {
                always {
                    // Archiver les rapports de tests
                    junit allowEmptyResults: true, testResults: "${env.TEST_PROJECT_PATH}/target/surefire-reports/*.xml"

                    // Archiver les screenshots en cas d'Ã©chec
                    archiveArtifacts artifacts: "${env.TEST_PROJECT_PATH}/target/screenshots/**/*.png", allowEmptyArchive: true
                }
            }
        }

        stage('ğŸ”’ Tests SÃ©curitÃ© OWASP ZAP') {
            steps {
                script {
                    echo "â–¶ ExÃ©cution des tests de sÃ©curitÃ© OWASP ZAP..."
                }

                sh """
                    echo "â–¶ DÃ©marrage du container OWASP ZAP..."

                    # ArrÃªter et supprimer le container ZAP s'il existe
                    docker rm -f ${env.CONTAINER_ZAP} 2>/dev/null || true

                    # DÃ©marrer ZAP en mode daemon
                    docker run -d --name ${env.CONTAINER_ZAP} \\
                        --network ${env.NETWORK_JENKINS} \\
                        -v \$(pwd)/zap-reports:/zap/wrk/:rw \\
                        -u zap \\
                        ghcr.io/zaproxy/zaproxy:stable \\
                        zap.sh -daemon -host 0.0.0.0 -port 8080 -config api.addrs.addr.name=.* -config api.addrs.addr.regex=true -config api.key=jenkins-zap-api-key

                    echo "â³ Attente du dÃ©marrage de ZAP..."
                    sleep 30

                    echo "â–¶ Lancement du scan ZAP sur https://${env.TEST_DOMAIN}..."

                    # ExÃ©cuter le scan ZAP (baseline scan)
                    docker exec ${env.CONTAINER_ZAP} \\
                        zap-baseline.py \\
                        -t https://${env.CONTAINER_NGINX} \\
                        -r zap-report.html \\
                        -w zap-report.md \\
                        -J zap-report.json \\
                        -x zap-report.xml \\
                        || true

                    echo "âœ… Scan ZAP terminÃ©"
                """
            }
            post {
                always {
                    // Copier les rapports ZAP
                    sh """
                        mkdir -p zap-reports
                        docker cp ${env.CONTAINER_ZAP}:/zap/wrk/zap-report.html zap-reports/ 2>/dev/null || true
                        docker cp ${env.CONTAINER_ZAP}:/zap/wrk/zap-report.xml zap-reports/ 2>/dev/null || true
                        docker cp ${env.CONTAINER_ZAP}:/zap/wrk/zap-report.json zap-reports/ 2>/dev/null || true
                    """

                    // Publier le rapport HTML
                    publishHTML([
                        allowMissing: true,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'zap-reports',
                        reportFiles: 'zap-report.html',
                        reportName: 'OWASP ZAP Security Report'
                    ])

                    // Archiver tous les rapports ZAP
                    archiveArtifacts artifacts: 'zap-reports/*', allowEmptyArchive: true

                    // ArrÃªter et supprimer le container ZAP
                    sh "docker rm -f ${env.CONTAINER_ZAP} 2>/dev/null || true"
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 6 : PUBLICATION DE L'IMAGE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸ·ï¸ Tag et Publication Image') {
            when {
                expression { params.PUBLISH_IMAGE == true }
            }
            steps {
                script {
                    echo "â–¶ Tag et publication de l'image Docker sur le registry..."

                    // DÃ©terminer le tag final
                    def finalTag = "${env.APP_VERSION}${params.IMAGE_TAG_SUFFIX}"
                    env.FINAL_IMAGE_TAG = finalTag

                    echo "   Tag final: ${finalTag}"
                }

                sh """
                    # DÃ©tecter le nom du registry
                    REGISTRY_NAME=\$(docker ps --filter "publish=5000" --format '{{.Names}}' | head -n 1)

                    if [ -z "\$REGISTRY_NAME" ]; then
                        echo "âŒ Erreur: Aucun registry Docker trouvÃ© sur le port 5000"
                        exit 1
                    fi

                    echo "â–¶ Registry dÃ©tectÃ©: \$REGISTRY_NAME"

                    # Tag de l'image avec la version finale
                    echo "â–¶ Tag de l'image: ${env.DOCKER_IMAGE_NAME}:${env.FINAL_IMAGE_TAG}"
                    docker tag ${env.RHDEMO_IMAGE} ${env.DOCKER_IMAGE_NAME}:${env.FINAL_IMAGE_TAG}

                    # Tag pour le registry
                    echo "â–¶ Tag pour le registry: \$REGISTRY_NAME:5000/${env.DOCKER_IMAGE_NAME}:${env.FINAL_IMAGE_TAG}"
                    docker tag ${env.RHDEMO_IMAGE} \$REGISTRY_NAME:5000/${env.DOCKER_IMAGE_NAME}:${env.FINAL_IMAGE_TAG}

                    # Push vers le registry
                    echo "â–¶ Push vers le registry..."
                    docker push \$REGISTRY_NAME:5000/${env.DOCKER_IMAGE_NAME}:${env.FINAL_IMAGE_TAG}

                    # Tag latest
                    echo "â–¶ Tag latest..."
                    docker tag ${env.RHDEMO_IMAGE} \$REGISTRY_NAME:5000/${env.DOCKER_IMAGE_NAME}:latest
                    docker push \$REGISTRY_NAME:5000/${env.DOCKER_IMAGE_NAME}:latest

                    echo "âœ… Image publiÃ©e sur le registry:"
                    echo "   - \$REGISTRY_NAME:5000/${env.DOCKER_IMAGE_NAME}:${env.FINAL_IMAGE_TAG}"
                    echo "   - \$REGISTRY_NAME:5000/${env.DOCKER_IMAGE_NAME}:latest"
                """
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 7 : ARCHIVAGE ET RAPPORTS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸ“¦ Archivage Artifacts') {
            steps {
                script {
                    echo "â–¶ Archivage des artifacts..."
                }

                // Archiver le JAR
                archiveArtifacts artifacts: 'rhDemo/target/*.jar', fingerprint: true

                // Archiver les rapports de tests
                archiveArtifacts artifacts: 'rhDemo/target/surefire-reports/**', allowEmptyArchive: true

                // Archiver le rapport OWASP Dependency-Check
                archiveArtifacts artifacts: 'rhDemo/target/dependency-check-report.html', allowEmptyArchive: true
            }
        }

    } // fin stages

    post {
        always {
            script {
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo "Pipeline CI terminÃ©: ${currentBuild.currentResult}"
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

                // Nettoyage de l'environnement staging
                echo "ğŸ§¹ Nettoyage de l'environnement staging..."

                dir(env.STAGING_INFRA_PATH) {
                    sh """
                        # ArrÃªter et supprimer l'environnement Docker Compose
                        sudo docker compose -p ${env.COMPOSE_PROJECT_NAME} down -v 2>/dev/null || true

                        # Supprimer les containers isolÃ©s
                        docker rm -f ${env.CONTAINER_NGINX} ${env.CONTAINER_APP} ${env.CONTAINER_DB} ${env.CONTAINER_KEYCLOAK} ${env.CONTAINER_KEYCLOAK_DB} 2>/dev/null || true

                        # Supprimer l'image de build temporaire
                        docker rmi ${env.RHDEMO_IMAGE} 2>/dev/null || true
                    """
                }

                // Supprimer les fichiers de secrets
                sh """
                    rm -f ${env.SECRETS_DECRYPTED} 2>/dev/null || true
                    rm -f ${env.SECRETS_ENV_VARS} 2>/dev/null || true
                    rm -f ${env.SECRETS_RHDEMO} 2>/dev/null || true
                """

                echo "âœ… Nettoyage terminÃ©"
            }
        }
        success {
            script {
                echo "âœ… Build rÃ©ussi !"
                if (params.PUBLISH_IMAGE) {
                    echo "ğŸ“¦ Image publiÃ©e: ${env.DOCKER_IMAGE_NAME}:${env.FINAL_IMAGE_TAG}"
                    echo "ğŸš€ PrÃªte pour le dÃ©ploiement CD sur stagingkub"
                    echo ""
                    echo "Pour dÃ©ployer sur stagingkub, utilisez le pipeline Jenkinsfile-CD avec:"
                    echo "   IMAGE_TAG=${env.FINAL_IMAGE_TAG}"
                }
            }
        }
        failure {
            script {
                echo "âŒ Build Ã©chouÃ© !"
                echo "Consultez les logs pour plus de dÃ©tails."
            }
        }
    }
}
