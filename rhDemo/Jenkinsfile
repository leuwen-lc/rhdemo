/*
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * âš ï¸  FICHIER DÃ‰PRÃ‰CIÃ‰ - NE PLUS UTILISER
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Ce fichier est conservÃ© pour compatibilitÃ© mais NE DOIT PLUS ÃŠTRE UTILISÃ‰.
 *
 * NOUVEAUX PIPELINES Ã€ UTILISER :
 *   - Jenkinsfile-CI : Pipeline d'IntÃ©gration Continue (build, tests, publish)
 *   - Jenkinsfile-CD : Pipeline de DÃ©ploiement Continu (deploy to stagingkub)
 *
 * Ce fichier sera supprimÃ© dans une version future.
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

pipeline {
    agent any

    options {
        // Timeout global : Ã©choue si le pipeline dÃ©passe 2 heures
        timeout(time: 2, unit: 'HOURS')

        // Ajoute des timestamps dans les logs console
        timestamps()

        // Conservation des builds (garde les 30 derniers)
        buildDiscarder(logRotator(numToKeepStr: '30', artifactNumToKeepStr: '10'))
    }

    tools {
        jdk 'JDK21'  // Nom configurÃ© dans Jenkins Global Tool Configuration
        maven 'Maven3' // Nom configurÃ© dans Jenkins Global Tool Configuration
    }

    environment {
        // Configuration du pipeline
        APP_NAME = 'rhdemo-api'
        // La version est lue dynamiquement depuis pom.xml (voir stage 'Lecture Version')
        // NOTE: APP_VERSION, JAR_FILE et DOCKER_IMAGE_TAG ne sont PAS dÃ©clarÃ©s ici
        // car ils doivent Ãªtre modifiables dynamiquement dans les stages

        // Configuration notifications email
        // Ã€ configurer : remplacer par votre email ou utiliser Jenkins Credentials
        //NOTIFICATION_EMAIL = 'moi@monserveur.com'

        // Configuration Docker
        DOCKER_IMAGE_NAME = "rhdemo-api"
        DOCKER_REGISTRY = "" // Laisser vide pour Docker Hub ou spÃ©cifier registry privÃ©

        // Versions des images Docker de base
        NGINX_IMAGE = "nginx:1.29.4-alpine"
        POSTGRES_IMAGE = "postgres:16-alpine"
        KEYCLOAK_IMAGE = "quay.io/keycloak/keycloak:26.4.2"

        // Configuration des tests
        TEST_PORT = '9000'
        TEST_PROJECT_PATH = 'rhDemoAPITestIHM'

        // Fichiers de secrets SOPS
        SECRETS_FILE = 'rhDemo/secrets/secrets-ephemere.yml'
        SECRETS_DECRYPTED = 'rhDemo/secrets/secrets-decrypted.yml'
        SECRETS_ENV_VARS = 'rhDemo/secrets/env-vars.sh'
        SECRETS_RHDEMO = 'rhDemo/secrets/secrets-rhdemo.yml'

        // Configuration environnement ephemere (Docker Compose)
        EPHEMERE_INFRA_PATH = 'rhDemo/infra/ephemere'
        KEYCLOAK_INIT_PATH = 'rhDemoInitKeycloak'
        TEST_DOMAIN = 'rhdemo.ephemere.local'
        KEYCLOAK_DOMAIN = 'keycloak.ephemere.local'
        COMPOSE_PROJECT_NAME = "rhdemo-ephemere-${env.BUILD_NUMBER}"
        RHDEMO_IMAGE = "${DOCKER_IMAGE_NAME}:build-${env.BUILD_NUMBER}"

        // Noms des conteneurs Docker (centralisÃ©s pour faciliter maintenance)
        CONTAINER_NGINX = 'rhdemo-ephemere-nginx'
        CONTAINER_APP = 'rhdemo-ephemere-app'
        CONTAINER_KEYCLOAK = 'keycloak-ephemere'
        CONTAINER_KEYCLOAK_DB = 'keycloak-ephemere-db'
        CONTAINER_DB = 'rhdemo-ephemere-db'
        CONTAINER_ZAP = 'rhdemo-jenkins-zap'

        // Noms des rÃ©seaux Docker
        NETWORK_EPHEMERE = 'rhdemo-ephemere-network'
        NETWORK_JENKINS = 'rhdemo-jenkins-network'
    }
    
    parameters {
        choice(name: 'DEPLOY_ENV', choices: ['ephemere', 'stagingkub', 'production', 'none'], description: 'Environnement de dÃ©ploiement: ephemere=Docker Compose, stagingkub=Kubernetes (KinD), production=production, none=build+tests uniquement')
        booleanParam(name: 'RUN_SELENIUM_TESTS', defaultValue: true, description: 'ExÃ©cuter les tests Selenium (ignorÃ© si DEPLOY_ENV=none)')
        booleanParam(name: 'RUN_SONAR', defaultValue: true, description: 'ExÃ©cuter l\'analyse SonarQube')
        booleanParam(name: 'SKIP_MANUAL_APPROVAL', defaultValue: false, description: 'Ignorer l\'approbation manuelle pour la production')
    }
    
    stages {
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 1 : PRÃ‰PARATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        stage('ğŸ› ï¸ Checkout') {
            steps {
                script {
                    echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
                    echo '  PHASE 1 : PRÃ‰PARATION'
                    echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
                }
                checkout scm
                sh 'git log -1 --pretty=format:"%h - %an : %s"'

                script {
                    echo 'â–¶ VÃ©rification du projet rhDemoInitKeycloak...'
                    // rhDemoInitKeycloak est dans le MÃŠME repo que rhDemo
                    // Le checkout SCM rÃ©cupÃ¨re en principe tout le workspace
                }

                sh '''
                    if [ -d "rhDemoInitKeycloak" ]; then
                        echo "âœ… rhDemoInitKeycloak trouvÃ© dans le workspace"
                        ls -la rhDemoInitKeycloak
                    else
                        echo "âŒ rhDemoInitKeycloak introuvable"
                        echo "Structure du workspace:"
                        ls -la
                        exit 1
                    fi
                '''
            }
        }

        stage('ğŸ”¢ Lecture Version Maven') {
            steps {
                script {
                    echo 'â–¶ Lecture de la version depuis pom.xml...'

                    // Lire la version depuis le pom.xml avec Maven
                    // NOTE: APP_VERSION, JAR_FILE et DOCKER_IMAGE_TAG ne sont PAS dans le bloc environment{}
                    // car les variables du bloc environment{} sont read-only en pipeline dÃ©claratif
                    env.APP_VERSION = sh(
                        script: 'cd rhDemo && ./mvnw help:evaluate -Dexpression=project.version -q -DforceStdout',
                        returnStdout: true
                    ).trim()

                    // VÃ©rifier que la lecture a rÃ©ussi
                    if (!env.APP_VERSION || env.APP_VERSION == '') {
                        error("âŒ Impossible de lire la version depuis pom.xml")
                    }

                    // Construire le nom du fichier JAR avec la version lue
                    env.JAR_FILE = "rhDemo/target/rhdemoAPI-${env.APP_VERSION}.jar"

                    // Mettre Ã  jour les variables Docker
                    env.DOCKER_IMAGE_TAG = env.APP_VERSION

                    echo "âœ… Version Maven dÃ©tectÃ©e: ${env.APP_VERSION}"
                    echo "   JAR attendu: ${env.JAR_FILE}"
                    echo "   Docker tag: ${env.DOCKER_IMAGE_TAG}"
                }
            }
        }

        stage('ğŸ”‘ Initialisation Variables Dynamiques') {
            steps {
                script {
                    echo 'â–¶ GÃ©nÃ©ration de la clÃ© API OWASP ZAP...'

                    // GÃ©nÃ©rer une clÃ© API alÃ©atoire pour ZAP ou rÃ©cupÃ©rer depuis secrets
                    def zapApiKey = sh(
                        script: '''
                            # Essayer de charger depuis secrets si disponible
                            if [ -f "rhDemo/secrets/env-vars.sh" ]; then
                                . rhDemo/secrets/env-vars.sh
                                if [ -n "$ZAP_API_KEY" ]; then
                                    echo "$ZAP_API_KEY"
                                    exit 0
                                fi
                            fi
                            # Sinon gÃ©nÃ©rer une nouvelle clÃ©
                            cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1
                        ''',
                        returnStdout: true
                    ).trim()

                    // Stocker comme variable d'environnement globale du pipeline
                    env.ZAP_API_KEY = zapApiKey
                    echo "âœ… ClÃ© API ZAP initialisÃ©e: ${zapApiKey.take(8)}..."
                }
            }
        }

        stage('ğŸ”“ DÃ©chiffrement Secrets SOPS') {
            steps {
                script {
                    echo 'â–¶ VÃ©rification SOPS et YQ...'
                }
                sh '''
                    sops --version
                    yq --version
                '''
                
                script {
                    echo 'â–¶ DÃ©chiffrement du fichier de secrets...'
                }
                
                // Utiliser le credential sops-age-key de maniÃ¨re sÃ©curisÃ©e
                withCredentials([file(credentialsId: 'sops-age-key', variable: 'SOPS_AGE_KEY_FILE')]) {
                    sh '''
                        # CrÃ©er le rÃ©pertoire secrets s'il n'existe pas
                        mkdir -p rhDemo/secrets
                        
                        # DÃ©chiffrer le fichier de secrets
                        echo "DÃ©chiffrement de ${SECRETS_FILE}..."
                        sops -d ${SECRETS_FILE} > ${SECRETS_DECRYPTED}
                        
                        # VÃ©rifier que le fichier a Ã©tÃ© dÃ©chiffrÃ©
                        if [ ! -f ${SECRETS_DECRYPTED} ]; then
                            echo "âŒ Ã‰chec du dÃ©chiffrement"
                            exit 1
                        fi
                        
                        echo "âœ… Secrets dÃ©chiffrÃ©s avec succÃ¨s"
                        
                        # Extraire les valeurs pour les variables d'environnement
                        # SÃ‰CURITÃ‰: DÃ©sactiver l'Ã©cho des commandes pour ne pas exposer les secrets dans les logs
                        set +x

                        # Exporter les secrets comme variables d'environnement pour les stages suivants
                        # Utilisation de substitution de variables sans affichage dans stdout
                        {
                            # PROTECTION: DÃ©sactiver l'Ã©cho pour Ã©viter l'exposition des secrets lors du sourcing
                            echo "# SÃ‰CURITÃ‰: Ce fichier contient des secrets - dÃ©sactive automatiquement le tracing bash"
                            echo "# DÃ©sactiver le tracing pour ne pas logger les secrets"
                            echo "{ set +x; } 2>/dev/null"
                            echo ""

                            echo "export RHDEMO_DATASOURCE_PASSWORD_PG=$(yq eval '.rhdemo.datasource.password.pg' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_DATASOURCE_PASSWORD_H2=$(yq eval '.rhdemo.datasource.password.h2' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET=$(yq eval '.rhdemo.client.registration.keycloak.client.secret' ${SECRETS_DECRYPTED})"

                            # Mots de passe Keycloak pour environnement ephemere
                            echo "export KEYCLOAK_DB_PASSWORD=$(yq eval '.keycloak.db.password' ${SECRETS_DECRYPTED})"
                            echo "export KEYCLOAK_ADMIN_PASSWORD=$(yq eval '.keycloak.admin.password' ${SECRETS_DECRYPTED})"
                            echo "export KEYCLOAK_ADMIN_USER=$(yq eval '.keycloak.admin.user // "admin"' ${SECRETS_DECRYPTED})"

                            # Utilisateurs et mots de passe de test (chiffrÃ©s dans SOPS)
                            echo "export RHDEMO_TEST_ID_USER_ADMIN=$(yq eval '.rhdemo.test.iduseradmin' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_TEST_PWD_USER_ADMIN=$(yq eval '.rhdemo.test.pwduseradmin' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_TEST_ID_USER_MAJ=$(yq eval '.rhdemo.test.idusermaj' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_TEST_PWD_USER_MAJ=$(yq eval '.rhdemo.test.pwdusermaj' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_TEST_ID_USER_CONSULT=$(yq eval '.rhdemo.test.iduserconsult' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_TEST_PWD_USER_CONSULT=$(yq eval '.rhdemo.test.pwduserconsult' ${SECRETS_DECRYPTED})"

                            # URLs des serveurs si elles existent
                            if yq eval '.rhdemo.servers.ephemere' ${SECRETS_DECRYPTED} > /dev/null 2>&1; then
                                echo "export EPHEMERE_SERVER=$(yq eval '.rhdemo.servers.ephemere' ${SECRETS_DECRYPTED})"
                            fi

                            if yq eval '.rhdemo.servers.production' ${SECRETS_DECRYPTED} > /dev/null 2>&1; then
                                echo "export PROD_SERVER=$(yq eval '.rhdemo.servers.production' ${SECRETS_DECRYPTED})"
                            fi
                        } > rhDemo/secrets/env-vars.sh 2>&1

                        # RÃ©activer l'Ã©cho des commandes
                        set -x

                        # Afficher (sans montrer les valeurs)
                        echo "âœ… Variables d'environnement prÃ©parÃ©es"
                    '''
                }
            }
            post {
                always {
                    script {
                        // Supprimer le fichier dÃ©chiffrÃ© pour la sÃ©curitÃ©
                        sh 'rm -f ${SECRETS_DECRYPTED} || true'
                    }
                }
            }
        }

        stage('ğŸ” Extraction secrets rhDemo') {
            steps {
                script {
                    echo 'â–¶ CrÃ©ation du fichier secrets-rhdemo.yml pour rhDemo (uniquement les secrets nÃ©cessaires)...'
                }

                sh '''
                    # SÃ‰CURITÃ‰: DÃ©sactiver l'Ã©cho des commandes
                    set +x

                    # Source les secrets
                    . rhDemo/secrets/env-vars.sh

                    # CrÃ©er un fichier secrets-rhdemo.yml contenant UNIQUEMENT les secrets rhDemo
                    # Ce fichier sera montÃ© dans le container Docker de rhDemo
                    cat > rhDemo/secrets/secrets-rhdemo.yml <<EOF

rhdemo:
  datasource:
    password:
      pg: ${RHDEMO_DATASOURCE_PASSWORD_PG}
      h2: ${RHDEMO_DATASOURCE_PASSWORD_H2}
  client:
    registration:
      keycloak:
        client:
          secret: ${RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET}
EOF

                    # RÃ©activer l'Ã©cho
                    set -x

                    echo "âœ… Fichier rhDemo/secrets/secrets-rhdemo.yml crÃ©Ã© (secrets limitÃ©s Ã  rhDemo uniquement)"
                '''
            }
        }

        stage('ğŸ”§ Configuration rhDemoInitKeycloak') {
            steps {
                script {
                    echo 'â–¶ GÃ©nÃ©ration de application-ephemere.yml pour rhDemoInitKeycloak...'
                    echo '   (Sera utilisÃ© directement via mvnw spring-boot:run, sans packaging JAR)'
                }
                
                sh '''
                    # SÃ‰CURITÃ‰: DÃ©sactiver l'Ã©cho des commandes pour ne pas exposer les secrets
                    set +x

                    # Source les secrets dÃ©chiffrÃ©s
                    . rhDemo/secrets/env-vars.sh

                    # GÃ©nÃ©rer application-ephemere.yml (sera utilisÃ© directement par Maven)
                    # NOTE: set +x reste actif pendant la gÃ©nÃ©ration pour ne pas logger les secrets
                    CONFIG_FILE="rhDemoInitKeycloak/src/main/resources/application-ephemere.yml"

                    # IMPORTANT: Sans guillemets sur YMLEOF pour que bash substitue les variables
                    cat > "${CONFIG_FILE}" << YMLEOF
# ========================================
# Configuration Keycloak Server - EPHEMERE
# GÃ©nÃ©rÃ©e automatiquement par Jenkins CI/CD
# ========================================
keycloak:
  # URL interne HTTP pour rhDemoInitKeycloak (exÃ©cutÃ© dans le rÃ©seau Docker)
  # Pas besoin de HTTPS car communication interne sÃ©curisÃ©e par le rÃ©seau isolÃ©
  server-url: http://keycloak-ephemere:8080
  
  admin:
    realm: master
    username: ${KEYCLOAK_ADMIN_USER}
    password: ${KEYCLOAK_ADMIN_PASSWORD}
  
  # ========================================
  # Configuration du Realm RHDemo
  # ========================================
  realm:
    name: RHDemo
    display-name: RHDemo Application
    enabled: true
    registration-allowed: false
    registration-email-as-username: false
    reset-password-allowed: true
    edit-username-allowed: false
    login-with-email-allowed: true
    duplicate-emails-allowed: false
    remember-me: true
    sso-session-idle-timeout: 1800
    sso-session-max-lifespan: 36000
    access-token-lifespan: 300
  
  # ========================================
  # Configuration du Client RHDemo
  # ========================================
  client:
    client-id: RHDemo
    name: RHDemo
    secret: ${RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET}
    root-url: https://${TEST_DOMAIN}:58443/
    base-url: ''
    admin-url: ''
    redirect-uris:
      - https://${TEST_DOMAIN}:58443/*
      - http://localhost:9000/*
      - https://rhdemo.ephemere.local:58443/*
      - https://keycloak.ephemere.local:58443/*
    web-origins:
      - https://${TEST_DOMAIN}:58443
      - http://localhost:9000
      - https://rhdemo.ephemere.local:58443
      - https://keycloak.ephemere.local:58443
    roles:
      - ROLE_admin
      - ROLE_consult
      - ROLE_MAJ
  
  # ========================================
  # Configuration des Utilisateurs de test
  # ========================================
  users:
    - username: ${RHDEMO_TEST_ID_USER_ADMIN}
      password: ${RHDEMO_TEST_PWD_USER_ADMIN}
      email: ${RHDEMO_TEST_ID_USER_ADMIN}@rhdemo.local
      first-name: Admin
      last-name: RHDemo
      roles:
        - ROLE_admin

    - username: ${RHDEMO_TEST_ID_USER_CONSULT}
      password: ${RHDEMO_TEST_PWD_USER_CONSULT}
      email: ${RHDEMO_TEST_ID_USER_CONSULT}@rhdemo.local
      first-name: Jean
      last-name: Consultant
      roles:
        - ROLE_consult

    - username: ${RHDEMO_TEST_ID_USER_MAJ}
      password: ${RHDEMO_TEST_PWD_USER_MAJ}
      email: ${RHDEMO_TEST_ID_USER_MAJ}@rhdemo.local
      first-name: Marie
      last-name: Manager
      roles:
        - ROLE_consult
        - ROLE_MAJ
YMLEOF

                    # RÃ©activer l'Ã©cho maintenant que les secrets ont Ã©tÃ© Ã©crits dans le fichier
                    set -x

                    echo "âœ… Configuration gÃ©nÃ©rÃ©e: ${CONFIG_FILE}"
                    
                    # VÃ©rifier que les variables sont bien substituÃ©es (sans afficher les secrets)
                    echo ""
                    echo "ğŸ” VÃ©rification de la configuration:"
                    echo "   Root URL:"
                    grep "root-url:" "${CONFIG_FILE}"
                    
                    # VÃ©rifier qu'il n'y a pas de ${VAR} littÃ©rales (non substituÃ©es)
                    if grep -q '\${' "${CONFIG_FILE}"; then
                        echo "âŒ ERREUR: Variables non substituÃ©es dÃ©tectÃ©es!"
                        echo "   Variables trouvÃ©es:"
                        grep '\${' "${CONFIG_FILE}"
                        exit 1
                    fi
                    
                    echo "âœ… Configuration gÃ©nÃ©rÃ©e avec toutes les variables substituÃ©es"
                '''
                
                script {
                    echo 'âœ… rhDemoInitKeycloak configurÃ© (prÃªt pour exÃ©cution via mvnw avec profil ephemere)'
                }
            }
        }
        
        stage('ï¿½ğŸ” VÃ©rification Environnement') {
            steps {
                script {
                    echo 'â–¶ VÃ©rification de l\'environnement...'
                    // Charger les variables d'environnement depuis le fichier
                    sh '''
                        # Charger les secrets
                        . rhDemo/secrets/env-vars.sh
                        
                        echo "Java version:"
                        java -version
                        echo "\nMaven version:"
                        cd rhDemo && ./mvnw -version
                        echo "\nVariables d'environnement:"
                        # Compter les variables RHDEMO sans afficher leurs valeurs (sÃ©curitÃ©)
                        RHDEMO_VAR_COUNT=$(env | grep -c "^RHDEMO_" || echo "0")
                        echo "âœ… $RHDEMO_VAR_COUNT variables RHDEMO configurÃ©es (valeurs masquÃ©es pour sÃ©curitÃ©)"
                    '''
                }
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 2 : BUILD
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        stage('ğŸ“¦ Compilation Backend') {
            steps {
                script {
                    echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
                    echo '  PHASE 2 : BUILD'
                    echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
                    echo 'â–¶ Compilation du backend Spring Boot...'
                }
                sh '''
                    # Charger les secrets pour la compilation
                    . rhDemo/secrets/env-vars.sh
                    cd rhDemo && ./mvnw clean compile -DskipTests
                '''
            }
        }
        
        stage('ğŸ¨ Build Frontend Vue.js') {
            steps {
                script {
                    echo 'â–¶ Build du frontend Vue.js via Maven...'
                }
                sh '''
                    echo "Installation Node.js et build Vue.js automatique via frontend-maven-plugin"
                    cd rhDemo/frontend
                    ls -la node/ || echo "Node.js sera installÃ© par Maven"
                '''
            }
        }
        
        stage('ğŸ”¨ Build') {
            steps {
                script {
                    echo "ğŸ”¨ Compilation et packaging de l'application..."
                    sh """
                        . rhDemo/secrets/env-vars.sh
                        cd rhDemo && ./mvnw clean package -DskipTests
                    """
                }
            }
        }

        stage('ğŸ”’ Analyse SÃ©curitÃ© DÃ©pendances (OWASP)') {
            steps {
                script {
                    echo 'â–¶ Analyse des vulnÃ©rabilitÃ©s des dÃ©pendances (OWASP Dependency-Check)...'
                    echo '   âš ï¸  Le build Ã©chouera si vulnÃ©rabilitÃ©s CVSS â‰¥ 7.0 (High/Critical)'
                    echo '   ğŸ“Œ Utilisation du plugin Maven OWASP Dependency-Check 12.1.9'

                    // ExÃ©cuter OWASP Dependency-Check via Maven
                    dir('rhDemo') {
                        // Tenter d'utiliser Ã  la fois NVD API key et OSS Index credentials
                        def nvdKeyAvailable = false
                        def ossIndexAvailable = false

                        try {
                            withCredentials([string(credentialsId: 'nvd-api-key', variable: 'NVD_API_KEY')]) {
                                nvdKeyAvailable = true
                                echo '   âœ… ClÃ© API NVD configurÃ©e'
                            }
                        } catch (Exception e) {
                            echo '   âš ï¸  ClÃ© API NVD non configurÃ©e - l\'analyse NVD sera plus lente'
                        }

                        try {
                            withCredentials([usernamePassword(credentialsId: 'ossindex-credentials', usernameVariable: 'OSSINDEX_USER', passwordVariable: 'OSSINDEX_PASS')]) {
                                ossIndexAvailable = true
                                echo '   âœ… Credentials OSS Index configurÃ©s'
                            }
                        } catch (Exception e) {
                            echo '   âš ï¸  Credentials OSS Index non configurÃ©s'
                            echo '   ğŸ’¡ CrÃ©ez un compte sur https://ossindex.sonatype.org/'
                            echo '   ğŸ’¡ Puis crÃ©ez le credential "ossindex-credentials" (Username with password) dans Jenkins'
                        }

                        // Construire la commande Maven avec les credentials disponibles
                        def mavenCmd = './mvnw org.owasp:dependency-check-maven:check'
                        def credentialsList = []

                        if (nvdKeyAvailable) {
                            credentialsList.add(string(credentialsId: 'nvd-api-key', variable: 'NVD_API_KEY'))
                        }

                        if (ossIndexAvailable) {
                            credentialsList.add(usernamePassword(credentialsId: 'ossindex-credentials', usernameVariable: 'OSSINDEX_USER', passwordVariable: 'OSSINDEX_PASS'))
                        }

                        if (credentialsList.isEmpty()) {
                            echo '   âš ï¸  ATTENTION: Aucun credential configurÃ© - l\'analyse sera limitÃ©e'
                            sh mavenCmd
                        } else {
                            withCredentials(credentialsList) {
                                if (nvdKeyAvailable && ossIndexAvailable) {
                                    sh './mvnw org.owasp:dependency-check-maven:check -DnvdApiKey="${NVD_API_KEY}" -DossIndexUsername="${OSSINDEX_USER}" -DossIndexPassword="${OSSINDEX_PASS}"'
                                } else if (nvdKeyAvailable) {
                                    sh './mvnw org.owasp:dependency-check-maven:check -DnvdApiKey="${NVD_API_KEY}"'
                                } else if (ossIndexAvailable) {
                                    sh './mvnw org.owasp:dependency-check-maven:check -DossIndexUsername="${OSSINDEX_USER}" -DossIndexPassword="${OSSINDEX_PASS}"'
                                }
                            }
                        }

                        // Afficher un rÃ©sumÃ© des vulnÃ©rabilitÃ©s et valider le rapport
                        sh '''#!/bin/bash
                            set -e  # Ã‰chouer immÃ©diatement en cas d'erreur

                            if [ ! -f "target/dependency-check-report.json" ]; then
                                echo "âŒ ERREUR: Rapport JSON non gÃ©nÃ©rÃ©"
                                echo "   L'analyse OWASP Dependency-Check a Ã©chouÃ©"
                                exit 1
                            fi

                            echo ""
                            echo "ğŸ“Š RÃ©sumÃ© des vulnÃ©rabilitÃ©s dÃ©tectÃ©es:"

                            TOTAL_DEPS=$(jq '.dependencies | length' target/dependency-check-report.json)
                            echo "   DÃ©pendances analysÃ©es: ${TOTAL_DEPS}"

                            # Valider que des dÃ©pendances ont Ã©tÃ© analysÃ©es
                            if [ "$TOTAL_DEPS" -eq 0 ]; then
                                echo "âŒ ERREUR: Aucune dÃ©pendance analysÃ©e"
                                echo "   VÃ©rifiez la configuration OWASP Dependency-Check"
                                exit 1
                            fi

                            DEPS_WITH_VULNS=$(jq '[.dependencies[] | select(.vulnerabilities != null)] | length' target/dependency-check-report.json)
                            echo "   DÃ©pendances avec vulnÃ©rabilitÃ©s: ${DEPS_WITH_VULNS}"

                            if [ "$DEPS_WITH_VULNS" -gt 0 ]; then
                                CRITICAL=$(jq '[.dependencies[].vulnerabilities[]? | select(.severity == "CRITICAL")] | length' target/dependency-check-report.json)
                                HIGH=$(jq '[.dependencies[].vulnerabilities[]? | select(.severity == "HIGH")] | length' target/dependency-check-report.json)
                                MEDIUM=$(jq '[.dependencies[].vulnerabilities[]? | select(.severity == "MEDIUM")] | length' target/dependency-check-report.json)
                                LOW=$(jq '[.dependencies[].vulnerabilities[]? | select(.severity == "LOW")] | length' target/dependency-check-report.json)

                                echo "   â”œâ”€ CRITICAL: ${CRITICAL}"
                                echo "   â”œâ”€ HIGH:     ${HIGH}"
                                echo "   â”œâ”€ MEDIUM:   ${MEDIUM}"
                                echo "   â””â”€ LOW:      ${LOW}"
                            else
                                echo "   âœ… Aucune vulnÃ©rabilitÃ© dÃ©tectÃ©e"
                            fi

                            # VÃ©rifier si l'analyse a rÃ©ellement fonctionnÃ© en cherchant les CPE/CVE identifiÃ©s
                            TOTAL_CVES=$(jq '[.dependencies[].vulnerabilities[]?.name // empty] | length' target/dependency-check-report.json 2>/dev/null || echo "0")
                            TOTAL_CPES=$(jq '[.dependencies[].packages[]?.id // empty] | length' target/dependency-check-report.json 2>/dev/null || echo "0")

                            echo ""
                            echo "ğŸ” Validation de l'analyse:"
                            echo "   CVEs identifiÃ©es: ${TOTAL_CVES}"
                            echo "   CPEs identifiÃ©es: ${TOTAL_CPES}"

                            # Si on a analysÃ© plus de 50 dÃ©pendances mais trouvÃ© 0 CVE, c'est suspect
                            if [ "$TOTAL_DEPS" -gt 50 ] && [ "$TOTAL_CVES" -eq 0 ]; then
                                echo ""
                                echo "âš ï¸  ATTENTION: Analyse suspecte dÃ©tectÃ©e"
                                echo "   ${TOTAL_DEPS} dÃ©pendances analysÃ©es mais 0 CVE trouvÃ©e"
                                echo "   Cela indique probablement un problÃ¨me de configuration:"
                                echo "   - OSS Index credentials manquants"
                                echo "   - NVD API key manquante ou invalide"
                                echo "   - Cache corrompue"
                                echo ""
                                echo "ğŸ’¡ Actions recommandÃ©es:"
                                echo "   1. Configurez les credentials OSS Index (ossindex-credentials)"
                                echo "   2. VÃ©rifiez la clÃ© NVD API (nvd-api-key)"
                                echo "   3. Nettoyez le cache: rm -rf ~/.m2/dependency-check-data"
                                echo ""
                                echo "âŒ Ã‰CHEC: Rapport non fiable - analyse incomplÃ¨te"
                                exit 1
                            fi

                            echo "âœ… Analyse validÃ©e avec succÃ¨s"
                            echo ""
                        '''
                    }
                }

                // Publier les rÃ©sultats OWASP
                // Note: Le rapport est gÃ©nÃ©rÃ© dans rhDemo/target/dependency-check-report.xml
                dependencyCheckPublisher(
                    pattern: 'rhDemo/target/dependency-check-report.xml',
                    failedTotalCritical: 1,    // Ã‰chec si â‰¥ 1 vulnÃ©rabilitÃ© Critical (CVSS 9.0-10.0)
                    failedTotalHigh: 1          // Ã‰chec si â‰¥ 1 vulnÃ©rabilitÃ© High (CVSS 7.0-8.9)
                    // Pas de seuils unstable* pour Ã©viter la redondance
                )

                // Archiver aussi les rapports HTML et JSON pour consultation
                archiveArtifacts artifacts: 'rhDemo/target/dependency-check-report.*', fingerprint: true, allowEmptyArchive: true

                // Archiver le log dÃ©taillÃ© pour diagnostic
                archiveArtifacts artifacts: 'rhDemo/target/dependency-check.log', fingerprint: true, allowEmptyArchive: true
            }
        }

        stage('ğŸ³ Build Docker Image') {
            when {
                expression { params.DEPLOY_ENV != 'none' }
            }
            steps {
                script {
                    // VÃ©rifier que APP_VERSION est dÃ©finie
                    if (!env.APP_VERSION || env.APP_VERSION == '') {
                        error("âŒ APP_VERSION non dÃ©finie ! Le stage 'Lecture Version Maven' a Ã©chouÃ©.")
                    }

                    echo "ğŸ³ Construction de l'image Docker avec Dockerfile (Eclipse Temurin 21)..."
                    echo "   Version Maven dÃ©tectÃ©e: ${env.APP_VERSION}"
                    echo "   Image Ã  construire: ${env.RHDEMO_IMAGE}"
                    echo "âš ï¸  Nettoyage complet: suppression images existantes..."

                    // Supprimer les anciennes images Docker pour forcer reconstruction
                    sh """
                        docker rmi ${env.RHDEMO_IMAGE} 2>/dev/null || echo "Image n'existe pas encore"
                        docker rmi ${env.DOCKER_IMAGE_NAME}:latest 2>/dev/null || echo "Image latest n'existe pas encore"
                    """

                    sh """
                        cd rhDemo
                        docker build -t ${env.RHDEMO_IMAGE} \
                                     -t ${env.DOCKER_IMAGE_NAME}:latest \
                                     --build-arg BUILD_DATE=\$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                                     --build-arg VCS_REF=\$(git rev-parse --short HEAD) \
                                     --build-arg VERSION=${env.APP_VERSION} \
                                     .
                    """

                    echo "âœ… Image Docker crÃ©Ã©e: ${env.RHDEMO_IMAGE}"

                    // Lister les images crÃ©Ã©es et afficher la taille
                    sh """
                        echo "ğŸ“Š Images crÃ©Ã©es:"
                        docker images ${env.DOCKER_IMAGE_NAME} --format "table {{.Repository}}:{{.Tag}}\\t{{.Size}}\\t{{.CreatedAt}}"
                    """
                }
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 3 : QUALITÃ‰ DU CODE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        stage('ğŸ§ª Tests Unitaires et IntÃ©gration') {
            steps {
                script {
                    echo "ğŸ§ª ExÃ©cution des tests unitaires et d'intÃ©gration..."
                    echo "   - Tests unitaires (Surefire)"
                    echo "   - Tests d'intÃ©gration (Failsafe)"
                    echo "   - GÃ©nÃ©ration du rapport JaCoCo agrÃ©gÃ© pour SonarQube"
                    sh """
                        . rhDemo/secrets/env-vars.sh
                        cd rhDemo && ./mvnw verify
                    """
                }
            }
        }
        
        stage('ğŸ” Analyse SonarQube') {
            when {
                expression { params.RUN_SONAR == true }
            }
            steps {
                script {
                    echo 'â–¶ Analyse de qualitÃ© du code avec SonarQube...'
                    echo '   - Envoi des mÃ©triques de couverture (tests unitaires + intÃ©gration)'
                }
                withSonarQubeEnv('SonarQube') {
                    sh """
                        # Charger les secrets pour l'analyse
                        . rhDemo/secrets/env-vars.sh
                        cd rhDemo && ./mvnw sonar:sonar \\
                            -Dsonar.projectKey=rhdemo-api \\
                            -Dsonar.projectName="RHDemo API" \\
                            -Dsonar.java.binaries=target/classes \\
                            -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml
                    """
                }
            }
        }

        stage('ğŸ¯ Quality Gate SonarQube') {
            when {
                expression { params.RUN_SONAR == true }
            }
            steps {
                script {
                    echo 'â–¶ Attente du Quality Gate SonarQube...'
                    echo '   (Webhook configurÃ©: http://jenkins:8080/sonarqube-webhook/)'
                }
                timeout(time: 5, unit: 'MINUTES') {
                    script {
                        def qg = waitForQualityGate()
                        if (qg.status != 'OK') {
                            error "Pipeline aborted due to quality gate failure: ${qg.status}"
                        }
                        echo "âœ… Quality Gate passed: ${qg.status}"
                    }
                }
            }
        }
        
        stage('ğŸ“ˆ Couverture de Code') {
            steps {
                script {
                    echo 'â–¶ GÃ©nÃ©ration du rapport de couverture JaCoCo...'
                }
                sh '''
                    # Charger les secrets pour le rapport
                    . rhDemo/secrets/env-vars.sh
                    cd rhDemo && ./mvnw jacoco:report
                '''
                jacoco(
                    execPattern: '**/rhDemo/target/jacoco.exec',
                    classPattern: '**/rhDemo/target/classes',
                    sourcePattern: '**/rhDemo/src/main/java'
                )
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 4 : ENVIRONNEMENT EPHEMERE (DOCKER COMPOSE)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        stage('âš™ï¸ Configuration Environnement Test') {
            when {
                expression { params.DEPLOY_ENV != 'none' }
            }
            steps {
                script {
                    echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
                    echo '  PHASE 4 : ENVIRONNEMENT EPHEMERE (DOCKER COMPOSE)'
                    echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
                    echo 'â–¶ Configuration de l\'environnement de test Docker Compose...'

                    // Nettoyer l'environnement prÃ©cÃ©dent si existant
                    sh """
                        cd ${EPHEMERE_INFRA_PATH}
                        
                        # ArrÃªter et supprimer les conteneurs du build prÃ©cÃ©dent
                        docker-compose -p ${COMPOSE_PROJECT_NAME} down -v 2>/dev/null || true
                        
                        # Supprimer les volumes orphelins (crÃ©Ã©s par builds prÃ©cÃ©dents avec noms diffÃ©rents)
                        docker volume rm keycloak-ephemere-db-data rhdemo-ephemere-db-data rhdemo-ephemere-nginx-cache 2>/dev/null || true
                        
                        # IMPORTANT: Supprimer l'image nginx locale pour forcer sa recrÃ©ation
                        # Ã‰vite les problÃ¨mes de layers corrompus oÃ¹ nginx.conf a Ã©tÃ© crÃ©Ã© comme rÃ©pertoire
                        echo "ğŸ§¹ Suppression image nginx pour Ã©viter layers corrompus..."
                        docker rmi ${NGINX_IMAGE} 2>/dev/null || true
                        
                        # Nettoyer les rÃ©seaux orphelins
                        docker network prune -f
                    """
                    
                    // Configuration du fichier hosts (si Jenkins tourne localement)
                    sh """
                        # VÃ©rifier si les entrÃ©es hosts existent
                        if ! grep -q "${TEST_DOMAIN}" /etc/hosts 2>/dev/null; then
                            echo "âš ï¸  ATTENTION: Ajouter '127.0.0.1 ${TEST_DOMAIN} ${KEYCLOAK_DOMAIN}' Ã  /etc/hosts"
                        fi
                    """
                }
            }
        }
        
        stage('ğŸ” GÃ©nÃ©ration Certificats SSL') {
            when {
                expression { params.DEPLOY_ENV != 'none' }
            }
            steps {
                script {
                    echo 'â–¶ GÃ©nÃ©ration des certificats SSL auto-signÃ©s...'
                }
                sh """
                    cd ${EPHEMERE_INFRA_PATH}
                    ./generate-certs.sh --domain ${TEST_DOMAIN} --domain ${KEYCLOAK_DOMAIN}
                """
            }
        }
        
        // NOTE: Ce stage n'est plus nÃ©cessaire car l'image est maintenant construite
        // directement avec le tag build-${BUILD_NUMBER} dans le stage "Build Docker Image"
        // stage('ğŸ·ï¸ Tag Image Docker') {
        //     when {
        //         expression { params.DEPLOY_ENV == 'ephemere' || params.DEPLOY_ENV == 'production' }
        //     }
        //     steps {
        //         script {
        //             echo "â–¶ Tag de l'image Docker..."
        //             echo "   Source: ${env.DOCKER_IMAGE_NAME}:${env.APP_VERSION}"
        //             echo "   Cible:  ${env.RHDEMO_IMAGE}"
        //         }
        //         sh """
        //             docker tag ${env.DOCKER_IMAGE_NAME}:${env.APP_VERSION} ${env.RHDEMO_IMAGE}
        //         """
        //     }
        // }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DÃ‰PLOIEMENT KUBERNETES (STAGINGKUB)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('â˜¸ï¸ Configure Kubernetes Access') {
            when {
                expression { params.DEPLOY_ENV == 'stagingkub' }
            }
            steps {
                script {
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "  CONFIGURATION DE L'ACCÃˆS KUBERNETES"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "â–¶ Configuration de kubectl pour le cluster KinD..."
                }
                sh """
                    # VÃ©rifier que le cluster KinD existe
                    if ! kind get clusters | grep -q "^rhdemo\$"; then
                        echo "âŒ Cluster KinD 'rhdemo' non trouvÃ©"
                        echo "   ExÃ©cutez d'abord: rhDemo/infra/stagingkub/scripts/init-stagingkub.sh"
                        exit 1
                    fi

                    echo "âœ… Cluster KinD 'rhdemo' trouvÃ©"

                    # Connecter Jenkins au rÃ©seau kind si nÃ©cessaire
                    JENKINS_CONTAINER=\$(hostname)
                    if ! docker network inspect kind 2>/dev/null | grep -q "\$JENKINS_CONTAINER"; then
                        echo "â–¶ Connexion de Jenkins au rÃ©seau kind..."
                        docker network connect kind \$JENKINS_CONTAINER 2>/dev/null && echo "âœ… Jenkins connectÃ© au rÃ©seau kind" || echo "âš ï¸  Impossible de connecter Jenkins au rÃ©seau kind"
                    else
                        echo "âœ… Jenkins dÃ©jÃ  connectÃ© au rÃ©seau kind"
                    fi

                    # GÃ©nÃ©rer une kubeconfig adaptÃ©e pour Jenkins
                    # Remplace l'adresse localhost par le nom DNS du container control-plane
                    echo "â–¶ GÃ©nÃ©ration de la configuration kubectl..."
                    kind get kubeconfig --name rhdemo | sed 's|https://127.0.0.1:[0-9]*|https://rhdemo-control-plane:6443|g' > /tmp/kubeconfig-kind

                    # Installer la kubeconfig
                    mkdir -p \$HOME/.kube
                    cp /tmp/kubeconfig-kind \$HOME/.kube/config
                    chmod 600 \$HOME/.kube/config
                    rm /tmp/kubeconfig-kind

                    echo "âœ… Configuration kubectl installÃ©e"

                    # VÃ©rifier l'accÃ¨s au cluster
                    echo "â–¶ VÃ©rification de l'accÃ¨s au cluster..."
                    if kubectl cluster-info 2>&1 | grep -q "is running"; then
                        echo "âœ… AccÃ¨s au cluster KinD confirmÃ©"
                        kubectl config use-context kind-rhdemo
                        echo "âœ… Contexte 'kind-rhdemo' activÃ©"
                    else
                        echo "âŒ Impossible d'accÃ©der au cluster KinD"
                        echo "   Logs de dÃ©bogage:"
                        kubectl cluster-info || true
                        exit 1
                    fi
                """
            }
        }

        stage('â˜¸ï¸ Push Image to Local Registry') {
            when {
                expression { params.DEPLOY_ENV == 'stagingkub' }
            }
            steps {
                script {
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "  DÃ‰PLOIEMENT KUBERNETES (STAGINGKUB)"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "â–¶ Push de l'image vers le registry local..."
                    echo "   Image source: ${env.DOCKER_IMAGE_NAME}:${env.APP_VERSION}"
                    echo "   Image cible: localhost:5000/${env.DOCKER_IMAGE_NAME}:${env.APP_VERSION}"
                }
                sh """
                    # DÃ©tection du registry sur le port 5000
                    REGISTRY_NAME=\$(docker ps --filter "publish=5000" --format '{{.Names}}' | head -n 1)

                    if [ -z "\$REGISTRY_NAME" ]; then
                        echo "âŒ Aucun registry actif sur le port 5000"

                        # Chercher un registry existant (mÃªme arrÃªtÃ©)
                        EXISTING_REGISTRY=\$(docker ps -a --filter "publish=5000" --format '{{.Names}}' | head -n 1)

                        if [ -n "\$EXISTING_REGISTRY" ]; then
                            echo "â–¶ Registry trouvÃ© mais arrÃªtÃ©: \$EXISTING_REGISTRY"
                            echo "  DÃ©marrage du registry..."
                            docker start \$EXISTING_REGISTRY
                            REGISTRY_NAME="\$EXISTING_REGISTRY"
                        else
                            # CrÃ©er un nouveau registry
                            echo "â–¶ Aucun registry trouvÃ©, crÃ©ation d'un nouveau..."
                            REGISTRY_NAME="kind-registry"
                            docker run -d --name \$REGISTRY_NAME --restart=always -p 5000:5000 registry:2
                            docker network connect kind \$REGISTRY_NAME 2>/dev/null || true
                        fi
                        sleep 2
                    fi

                    echo "âœ… Registry dÃ©tectÃ©: \$REGISTRY_NAME"

                    # DÃ©terminer l'URL d'accÃ¨s au registry
                    # Depuis Jenkins (container), on doit utiliser le nom du container, pas localhost
                    REGISTRY_URL="http://\$REGISTRY_NAME:5000"

                    # VÃ©rifier l'accessibilitÃ© HTTP via le nom du container
                    echo "â–¶ VÃ©rification de l'accessibilitÃ© via \$REGISTRY_URL..."
                    if curl -f \$REGISTRY_URL/v2/ 2>/dev/null; then
                        echo "âœ… Registry accessible via le rÃ©seau Docker"
                    else
                        echo "âš ï¸  Registry non accessible via \$REGISTRY_URL, tentative avec localhost..."
                        REGISTRY_URL="http://localhost:5000"
                        if ! curl -f \$REGISTRY_URL/v2/ 2>/dev/null; then
                            echo "âŒ Erreur: Registry introuvable"
                            echo "   VÃ©rifiez que Jenkins et le registry sont sur le mÃªme rÃ©seau Docker"
                            exit 1
                        fi
                    fi

                    # Tagger l'image pour le registry local
                    echo "â–¶ Tag de l'image..."
                    docker tag ${env.DOCKER_IMAGE_NAME}:${env.APP_VERSION} \\
                        localhost:5000/${env.DOCKER_IMAGE_NAME}:${env.APP_VERSION}

                    # Pousser l'image vers le registry
                    echo "â–¶ Push vers le registry..."
                    docker push localhost:5000/${env.DOCKER_IMAGE_NAME}:${env.APP_VERSION}

                    echo "âœ… Image poussÃ©e vers le registry local"

                    # VÃ©rifier que l'image est bien dans le registry
                    echo "â–¶ VÃ©rification de l'image dans le registry..."
                    curl -s \$REGISTRY_URL/v2/${env.DOCKER_IMAGE_NAME}/tags/list | grep ${env.APP_VERSION} || {
                        echo "âš ï¸  Avertissement: Image non visible dans le catalogue du registry"
                    }
                """
            }
        }

        stage('â˜¸ï¸ Update Kubernetes Secrets') {
            when {
                expression { params.DEPLOY_ENV == 'stagingkub' }
            }
            steps {
                script {
                    echo "â–¶ Mise Ã  jour des secrets Kubernetes..."
                }
                sh """
                    # SÃ‰CURITÃ‰: DÃ©sactiver l'Ã©cho des commandes pour ne pas exposer les secrets
                    set +x

                    # Charger les secrets depuis SOPS
                    . rhDemo/secrets/env-vars.sh

                    # Utiliser le contexte KinD
                    kubectl config use-context kind-rhdemo

                    # Mettre Ã  jour les secrets Kubernetes
                    kubectl create secret generic rhdemo-db-secret \\
                      --from-literal=password="\${RHDEMO_DATASOURCE_PASSWORD_PG}" \\
                      --namespace rhdemo-staging \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    kubectl create secret generic keycloak-db-secret \\
                      --from-literal=password="\${KEYCLOAK_DB_PASSWORD}" \\
                      --namespace rhdemo-staging \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    kubectl create secret generic keycloak-admin-secret \\
                      --from-literal=password="\${KEYCLOAK_ADMIN_PASSWORD}" \\
                      --namespace rhdemo-staging \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    # Mettre Ã  jour le secret pour secrets-rhdemo.yml
                    kubectl create secret generic rhdemo-app-secrets \\
                      --from-file=secrets-rhdemo.yml=rhDemo/secrets/secrets-rhdemo.yml \\
                      --namespace rhdemo-staging \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    echo "âœ… Secrets Kubernetes mis Ã  jour"
                """
            }
        }

        stage('â˜¸ï¸ Deploy to Kubernetes') {
            when {
                expression { params.DEPLOY_ENV == 'stagingkub' }
            }
            steps {
                script {
                    def registryName = sh(script: 'docker ps --filter "publish=5000" --format "{{.Names}}" | head -n 1', returnStdout: true).trim()
                    echo "â–¶ DÃ©ploiement avec Helm..."
                    echo "   Chart: rhDemo/infra/stagingkub/helm/rhdemo"
                    echo "   Registry: ${registryName}"
                    echo "   Image: ${registryName}:5000/${env.DOCKER_IMAGE_NAME}:${env.APP_VERSION}"
                    echo "   Namespace: rhdemo-staging"
                }
                sh """
                    # Utiliser le contexte KinD
                    kubectl config use-context kind-rhdemo

                    # DÃ©ployer ou mettre Ã  jour avec Helm
                    # IMPORTANT: Utiliser le nom DNS du registry (dÃ©tectÃ© dynamiquement)
                    # Note: Le namespace rhdemo-staging doit dÃ©jÃ  exister (crÃ©Ã© par init-stagingkub.sh)
                    helm upgrade --install rhdemo rhDemo/infra/stagingkub/helm/rhdemo \\
                      --namespace rhdemo-staging \\
                      --set rhdemo.image.repository=\$(docker ps --filter "publish=5000" --format '{{.Names}}' | head -n 1):5000/${env.DOCKER_IMAGE_NAME} \\
                      --set rhdemo.image.tag=${env.APP_VERSION} \\
                      --wait \\
                      --timeout 10m

                    echo ""
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "âœ… DÃ©ploiement Kubernetes rÃ©ussi"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo ""
                    echo "ğŸ“Š Statut des pods:"
                    kubectl get pods -n rhdemo-staging
                    echo ""
                    echo "ğŸ”— Services:"
                    kubectl get svc -n rhdemo-staging
                    echo ""
                    echo "ğŸŒ Ingress:"
                    kubectl get ingress -n rhdemo-staging
                    echo ""
                    echo "ğŸŒ URLs d'accÃ¨s:"
                    echo "   Application: https://rhdemo.staging.local"
                    echo "   Keycloak: https://keycloak.staging.local"
                """
            }
        }

        stage('â˜¸ï¸ Wait for Kubernetes Readiness') {
            when {
                expression { params.DEPLOY_ENV == 'stagingkub' }
            }
            steps {
                script {
                    echo "â–¶ Attente de la disponibilitÃ© des services..."
                }
                sh """
                    kubectl config use-context kind-rhdemo

                    # Attendre que tous les pods soient prÃªts
                    echo "â³ Attente des pods PostgreSQL..."
                    kubectl wait --for=condition=ready pod -l app=postgresql-rhdemo -n rhdemo-staging --timeout=300s
                    kubectl wait --for=condition=ready pod -l app=postgresql-keycloak -n rhdemo-staging --timeout=300s

                    echo "â³ Attente de Keycloak..."
                    kubectl wait --for=condition=ready pod -l app=keycloak -n rhdemo-staging --timeout=300s

                    echo "â³ Attente de l'application RHDemo..."
                    kubectl wait --for=condition=ready pod -l app=rhdemo-app -n rhdemo-staging --timeout=300s

                    echo "âœ… Tous les services sont prÃªts"
                """
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DÃ‰PLOIEMENT DOCKER COMPOSE (EPHEMERE/PRODUCTION)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸ³ DÃ©marrage Environnement Docker') {
            when {
                expression { params.DEPLOY_ENV == 'ephemere' || params.DEPLOY_ENV == 'production' }
            }
            steps {
                script {
                    echo 'â–¶ DÃ©marrage de l\'environnement Docker Compose (5 services)...'
                }
                sh """
                    # SÃ‰CURITÃ‰: DÃ©sactiver l'Ã©cho des commandes pour ne pas exposer les secrets
                    set +x

                    # Source les secrets SOPS
                    . rhDemo/secrets/env-vars.sh

                    cd ${EPHEMERE_INFRA_PATH}

                    # Variables d'environnement pour Docker Compose
                    # docker-compose.yml utilise image: rhdemo-api:\${APP_VERSION}
                    export APP_VERSION=build-${env.BUILD_NUMBER}
                    export WORKSPACE=\$(pwd)

                    # Export des versions d'images Docker (source de vÃ©ritÃ© : Jenkinsfile)
                    export NGINX_IMAGE=${env.NGINX_IMAGE}
                    export POSTGRES_IMAGE=${env.POSTGRES_IMAGE}
                    export KEYCLOAK_IMAGE=${env.KEYCLOAK_IMAGE}

                    # Export explicite des variables critiques (pour Ã©viter que .env les Ã©crase)
                    export RHDEMO_DB_PASSWORD="\${RHDEMO_DATASOURCE_PASSWORD_PG}"
                    export KEYCLOAK_DB_PASSWORD="\${KEYCLOAK_DB_PASSWORD}"
                    export KEYCLOAK_ADMIN_USER="\${KEYCLOAK_ADMIN_USER}"
                    export KEYCLOAK_ADMIN_PASSWORD="\${KEYCLOAK_ADMIN_PASSWORD}"
                    export RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET="\${RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET}"

                    # RÃ©activer l'Ã©cho APRÃˆS les exports de secrets
                    set -x

                    # Confirmation (sans afficher les secrets)
                    echo "âœ… Secrets exportÃ©s avec succÃ¨s (secrets non affichÃ©s pour sÃ©curitÃ©)"
                    
                    # IMPORTANT: Nettoyage forcÃ© des conteneurs existants pour Ã©viter les conflits de noms
                    echo "ğŸ§¹ Nettoyage des conteneurs ephemere existants..."
                    docker rm -f keycloak-ephemere-db rhdemo-ephemere-db keycloak-ephemere rhdemo-ephemere-app rhdemo-ephemere-nginx 2>/dev/null || true
                    echo "âœ… Conteneurs existants supprimÃ©s"
                    
                    # DÃ©marrer les conteneurs (plus besoin de docker-compose.jenkins.yml override)
                    echo "ğŸš€ DÃ©marrage des conteneurs Docker..."
                    docker-compose -f docker-compose.yml -p ${COMPOSE_PROJECT_NAME} up -d
                    
                    # Connecter Jenkins au rÃ©seau ephemere pour accÃ¨s direct aux services
                    echo "ğŸ”— Connexion de Jenkins au rÃ©seau ephemere..."
                    # Trouver le conteneur Jenkins principal (pas l'agent)
                    JENKINS_CONTAINER=\$(docker ps --filter "name=jenkins" --format "{{.Names}}" | grep -v agent | head -n 1)
                    echo "Conteneur Jenkins trouvÃ©: \$JENKINS_CONTAINER"
                    if [ -n "\$JENKINS_CONTAINER" ]; then
                        docker network connect rhdemo-ephemere-network \$JENKINS_CONTAINER 2>/dev/null || echo "âš ï¸  Jenkins dÃ©jÃ  connectÃ© au rÃ©seau"
                        echo "âœ… Jenkins (\$JENKINS_CONTAINER) connectÃ© au rÃ©seau rhdemo-ephemere-network"
                    else
                        echo "âŒ ERREUR: Conteneur Jenkins introuvable!"
                        docker ps --filter "name=jenkins"
                    fi
                    
                    # Attendre que les conteneurs dÃ©marrent (augmentÃ© pour Keycloak)
                    echo "â³ Attente dÃ©marrage conteneurs (20s)..."
                    sleep 20
                    
                    # Copier les configurations nginx et certificats SSL
                    echo "ğŸ“‹ Copie des configurations nginx..."
                    docker cp nginx/nginx.conf rhdemo-ephemere-nginx:/etc/nginx/nginx.conf
                    docker cp nginx/conf.d/. rhdemo-ephemere-nginx:/etc/nginx/conf.d/

                    if [ -d "certs" ]; then
                        docker cp certs/. rhdemo-ephemere-nginx:/etc/nginx/ssl/
                        echo "âœ… Configurations nginx et certificats copiÃ©s"
                    else
                        echo "âœ… Configurations nginx copiÃ©es (certificats manquants)"
                    fi

                    # Recharger la configuration nginx pour appliquer les changements
                    echo "ğŸ”„ Rechargement de la configuration nginx..."
                    docker exec rhdemo-ephemere-nginx nginx -t  # Test de la config
                    docker exec rhdemo-ephemere-nginx nginx -s reload  # Reload
                    echo "âœ… Nginx rechargÃ© avec la nouvelle configuration HTTPS"

                    # VÃ©rifier que nginx Ã©coute rÃ©ellement sur le port 58443
                    echo "ğŸ” VÃ©rification que nginx Ã©coute sur le port 58443..."
                    if docker exec rhdemo-ephemere-nginx netstat -tuln | grep -q ':443'; then
                        echo "âœ… Nginx Ã©coute sur le port 443 interne (mappÃ© sur 58443 externe)"
                    else
                        echo "âŒ ERREUR: Nginx n'Ã©coute PAS sur le port 443!"
                        echo "Ports Ã©coutÃ©s par nginx:"
                        docker exec rhdemo-ephemere-nginx netstat -tuln
                        exit 1
                    fi
                    
                    echo "âœ… Environnement Docker opÃ©rationnel:"
                    docker-compose -p ${COMPOSE_PROJECT_NAME} ps
                """
            }
        }

        stage('ğŸ” Injection secrets rhDemo dans container') {
            when {
                expression { params.DEPLOY_ENV != 'none' }
            }
            steps {
                script {
                    echo 'â–¶ Copie du fichier secrets-rhdemo.yml dans le container rhDemo...'
                    echo '   Ce fichier contient uniquement les secrets nÃ©cessaires Ã  rhDemo (moindre privilÃ¨ge)'
                }
                sh """
                    cd ${EPHEMERE_INFRA_PATH}

                    # Chemin du fichier secrets dans le workspace Jenkins
                    SECRETS_FILE="../../secrets/secrets-rhdemo.yml"

                    if [ ! -f "\$SECRETS_FILE" ]; then
                        echo "âŒ Erreur: Fichier secrets-rhdemo.yml introuvable"
                        echo "Recherche dans le workspace:"
                        find ../../ -name "secrets-rhdemo.yml" || echo "Aucun fichier trouvÃ©"
                        exit 1
                    fi

                    echo "ğŸ“‹ Copie du fichier secrets dans le container..."

                    # CrÃ©er le rÃ©pertoire en tant que root, puis changer le propriÃ©taire
                    # L'utilisateur spring n'a pas les droits root
                    docker exec --user root rhdemo-ephemere-app mkdir -p /workspace/secrets
                    docker exec --user root rhdemo-ephemere-app chown spring:spring /workspace/secrets

                    # Copier le fichier
                    docker cp "\$SECRETS_FILE" rhdemo-ephemere-app:/workspace/secrets/secrets-rhdemo.yml

                    # DÃ©finir les permissions (read-only) et le propriÃ©taire en tant que root
                    docker exec --user root rhdemo-ephemere-app chown spring:spring /workspace/secrets/secrets-rhdemo.yml
                    docker exec --user root rhdemo-ephemere-app chmod 400 /workspace/secrets/secrets-rhdemo.yml

                    echo "âœ… Fichier secrets-rhdemo.yml copiÃ© dans le container"
                    echo "   Chemin: /workspace/secrets/secrets-rhdemo.yml"
                    echo "   Permissions: 400 (read-only, propriÃ©taire: spring)"

                    # VÃ©rification (sans afficher le contenu pour sÃ©curitÃ©)
                    docker exec rhdemo-ephemere-app ls -lh /workspace/secrets/secrets-rhdemo.yml

                    # RedÃ©marrer l'application pour charger les secrets
                    # Spring Boot charge spring.config.import au dÃ©marrage uniquement
                    echo "ğŸ”„ RedÃ©marrage de l'application pour charger les secrets..."
                    docker-compose -f docker-compose.yml -p ${COMPOSE_PROJECT_NAME} restart rhdemo-app
                    echo "âœ… Application redÃ©marrÃ©e (healthcheck dans le stage dÃ©diÃ©)"
                """
            }
        }

        stage('ğŸ’¾ Initialisation Base de DonnÃ©es') {
            when {
                expression { params.DEPLOY_ENV != 'none' }
            }
            steps {
                script {
                    echo 'â–¶ Initialisation de la base de donnÃ©es PostgreSQL...'
                }
                sh """
                    cd ${EPHEMERE_INFRA_PATH}

                    # Attendre que PostgreSQL soit prÃªt
                    echo "â³ Attente PostgreSQL ready (30s max)..."
                    timeout=30
                    while [ \$timeout -gt 0 ]; do
                        if docker exec rhdemo-ephemere-db pg_isready -U rhdemo >/dev/null 2>&1; then
                            echo "âœ… PostgreSQL ready"
                            break
                        fi
                        sleep 2
                        timeout=\$((timeout - 2))
                    done

                    if [ \$timeout -le 0 ]; then
                        echo "âŒ Timeout: PostgreSQL n'est pas prÃªt aprÃ¨s 30s"
                        docker logs --tail=20 rhdemo-ephemere-db
                        exit 1
                    fi

                    # Copier et exÃ©cuter le schÃ©ma SQL + donnÃ©es de test
                    PGSCHEMA_PATH="../../pgschema.sql"
                    PGDATA_PATH="../../pgdata.sql"

                    if [ ! -f "\$PGSCHEMA_PATH" ]; then
                        echo "âŒ Erreur: Fichier pgschema.sql introuvable"
                        exit 1
                    fi
                    if [ ! -f "\$PGDATA_PATH" ]; then
                        echo "âŒ Erreur: Fichier pgdata.sql introuvable"
                        exit 1
                    fi

                    echo "ğŸ“‹ Copie du schÃ©ma SQL dans le container..."
                    docker cp "\$PGSCHEMA_PATH" rhdemo-ephemere-db:/tmp/schema.sql
                    docker cp "\$PGDATA_PATH" rhdemo-ephemere-db:/tmp/data.sql

                    echo "ğŸ”§ ExÃ©cution du schÃ©ma SQL (DROP + CREATE + INDEX)..."
                    docker exec rhdemo-ephemere-db psql -U rhdemo -d rhdemo -f /tmp/schema.sql

                    echo "ğŸ“Š Insertion des donnÃ©es de test..."
                    docker exec rhdemo-ephemere-db psql -U rhdemo -d rhdemo -f /tmp/data.sql

                    # VÃ©rifier le nombre d'employÃ©s insÃ©rÃ©s
                    EMPLOYEE_COUNT=\$(docker exec rhdemo-ephemere-db psql -U rhdemo -d rhdemo -t -c "SELECT COUNT(*) FROM employes;" | tr -d ' ')
                    
                    echo "âœ… Base de donnÃ©es initialisÃ©e"
                    echo "   ğŸ“Š Nombre d'employÃ©s: \$EMPLOYEE_COUNT"
                    
                    if [ "\$EMPLOYEE_COUNT" != "303" ]; then
                        echo "âš ï¸  Attention: Attendu 303 employÃ©s, trouvÃ© \$EMPLOYEE_COUNT"
                    fi
                """
            }
        }
        
        stage('ğŸ¥ Healthcheck Keycloak') {
            when {
                expression { params.DEPLOY_ENV != 'none' }
            }
            steps {
                script {
                    echo 'â–¶ Attente dÃ©marrage Keycloak...'

                    // Charger la bibliothÃ¨que
                    def lib = load 'rhDemo/vars/rhDemoLib.groovy'

                    // Healthcheck Keycloak avec attente initiale
                    lib.waitForHealthcheck([
                        name: 'Keycloak',
                        url: "http://${env.CONTAINER_KEYCLOAK}:9000/health/ready",
                        timeout: 60,
                        initialWait: 45,
                        container: env.CONTAINER_KEYCLOAK
                    ])
                }
            }
        }
        
        stage('ğŸ”‘ Initialisation Keycloak') {
            when {
                expression { params.DEPLOY_ENV != 'none' }
            }
            steps {
                script {
                    echo 'â–¶ Initialisation du realm Keycloak...'
                    echo 'CrÃ©ation du realm RHDemo, client et utilisateurs'
                }
                sh """
                    # SÃ‰CURITÃ‰: DÃ©sactiver l'Ã©cho des commandes pour ne pas exposer les secrets
                    set +x

                    # Source les secrets
                    . rhDemo/secrets/env-vars.sh

                    # RÃ©activer l'Ã©cho pour les commandes non sensibles
                    set -x

                    echo "ğŸš€ ExÃ©cution de rhDemoInitKeycloak via Maven..."
                    echo "   (Utilise directement application-ephemere.yml gÃ©nÃ©rÃ©, sans packaging)"

                    cd ${WORKSPACE}/rhDemoInitKeycloak

                    # VÃ©rification que le fichier de config existe
                    CONFIG_FILE="src/main/resources/application-ephemere.yml"
                    if [ ! -f "\${CONFIG_FILE}" ]; then
                        echo "âŒ Fichier de configuration manquant: \${CONFIG_FILE}"
                        exit 1
                    fi

                    echo "Configuration trouvÃ©e: \${CONFIG_FILE}"
                    echo ""
                    echo "âœ… Configuration Keycloak prÃ©parÃ©e (secrets non affichÃ©s pour sÃ©curitÃ©)"
                    echo ""

                    # ExÃ©cution directe via Maven Spring Boot plugin
                    if ./mvnw spring-boot:run -Dspring-boot.run.profiles=ephemere; then
                        echo ""
                        echo "âœ… Keycloak initialisÃ© avec succÃ¨s"
                        echo "   - Realm RHDemo crÃ©Ã©"
                        echo "   - Client RHDemo configurÃ©"
                        echo "   - 3 utilisateurs crÃ©Ã©s (admin, consultant, manager)"
                    else
                        echo ""
                        echo "âŒ Ã‰chec de l'initialisation Keycloak"
                        echo ""
                        echo "ğŸ“‹ Logs Keycloak pour diagnostic:"
                        docker logs --tail=30 keycloak-ephemere || true
                        exit 1
                    fi
                    
                    # Attendre propagation de la configuration
                    echo ""
                    echo "â³ Attente propagation config Keycloak (10s)..."
                    sleep 10
                """
            }
        }
        
        stage('ğŸ¥ Healthcheck Application RHDemo') {
            when {
                expression { params.DEPLOY_ENV != 'none' }
            }
            steps {
                script {
                    echo 'â–¶ VÃ©rification santÃ© de l\'application RHDemo...'

                    // Charger la bibliothÃ¨que
                    def lib = load 'rhDemo/vars/rhDemoLib.groovy'

                    // Healthcheck RHDemo App (accepte 301/302 car redirection OAuth2)
                    lib.waitForHealthcheck([
                        name: 'RHDemo App',
                        url: "http://${env.CONTAINER_APP}:9000/front/",
                        timeout: 90,
                        acceptedCodes: [200, 301, 302],
                        container: env.CONTAINER_APP
                    ])
                }
            }
        }
        
        stage('ğŸŒ Healthcheck Nginx HTTPS') {
            when {
                expression { params.DEPLOY_ENV != 'none' }
            }
            steps {
                script {
                    echo 'â–¶ VÃ©rification de l\'accÃ¨s HTTPS via nginx (test end-to-end)...'

                    // Charger la bibliothÃ¨que
                    def lib = load 'rhDemo/vars/rhDemoLib.groovy'

                    // Healthcheck Nginx HTTPS (test depuis Jenkins oÃ¹ Firefox tourne)
                    lib.waitForHealthcheck([
                        name: 'Nginx HTTPS',
                        url: 'https://rhdemo.ephemere.local:58443/front/',
                        timeout: 30,
                        acceptedCodes: [200, 302],
                        insecure: true,  // Certificat auto-signÃ©
                        container: env.CONTAINER_NGINX
                    ])

                    echo "âœ… Stack complÃ¨te opÃ©rationnelle et accessible via HTTPS"
                    echo "   PrÃªt pour les tests Selenium"
                }
            }
        }

        stage('ğŸ” Scan SÃ©curitÃ© Images Docker (Trivy)') {
            when {
                expression { params.DEPLOY_ENV != 'none' }
            }
            options {
                timeout(time: 8, unit: 'MINUTES')  // RÃ©duit de 15min Ã  8min grÃ¢ce Ã  la parallÃ©lisation
            }
            steps {
                script {
                    echo 'â–¶ Scan de sÃ©curitÃ© des images Docker avec Trivy (parallÃ©lisÃ©)...'
                    echo '   â„¹ï¸  Les 4 images seront scannÃ©es en parallÃ¨le pour optimiser le temps'
                    echo ''
                    echo '   âš ï¸  Le build Ã©chouera si vulnÃ©rabilitÃ©s CRITICAL dÃ©tectÃ©es'
                    echo '   â±ï¸  Timeout: 8 minutes (au lieu de 20 min sÃ©quentiel)'

                    // Charger la bibliothÃ¨que
                    def lib = load 'rhDemo/vars/rhDemoLib.groovy'

                    // CrÃ©er le rÃ©pertoire pour les rapports
                    sh 'mkdir -p trivy-reports'

                    // DÃ©finir les images Ã  scanner avec leurs noms de rapports
                    def imagesToScan = [
                        [image: env.POSTGRES_IMAGE, name: 'postgres'],
                        [image: env.KEYCLOAK_IMAGE, name: 'keycloak'],
                        [image: env.NGINX_IMAGE, name: 'nginx'],
                        [image: env.RHDEMO_IMAGE, name: 'rhdemo-app']
                    ]

                    echo "ğŸ“‹ Images Ã  scanner:"
                    imagesToScan.each { img ->
                        echo "   - ${img.name}: ${img.image}"
                    }

                    // CrÃ©er les stages parallÃ¨les de scan
                    def scanStages = imagesToScan.collectEntries { img ->
                        ["Scan ${img.name}": {
                            lib.generateTrivyReport(img.image, img.name)
                        }]
                    }

                    // ExÃ©cuter tous les scans en parallÃ¨le
                    parallel(scanStages + [failFast: false])

                    // AgrÃ©gation des rÃ©sultats et vÃ©rification des seuils
                    if (!lib.aggregateTrivyResults()) {
                        error("Trivy a dÃ©tectÃ© des vulnÃ©rabilitÃ©s CRITICAL bloquantes")
                    }
                }

                // Archiver les rapports Trivy (JSON et HTML)
                archiveArtifacts artifacts: 'trivy-reports/*.json', fingerprint: true, allowEmptyArchive: true
                archiveArtifacts artifacts: 'trivy-reports/*.html', fingerprint: true, allowEmptyArchive: true
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 5 : TESTS FONCTIONNELS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸ”’ DÃ©marrage OWASP ZAP Proxy') {
            when {
                allOf {
                    expression { params.DEPLOY_ENV != 'none' }
                    expression { params.RUN_SELENIUM_TESTS == true }
                }
            }
            steps {
                script {
                    echo 'â–¶ DÃ©marrage du proxy OWASP ZAP pour analyse de sÃ©curitÃ©...'
                    echo '   Le trafic Selenium sera interceptÃ© et analysÃ© par ZAP'
                }

                sh """#!/bin/bash
                    # Utiliser la clÃ© API ZAP dÃ©finie comme variable d'environnement Jenkins
                    echo "ğŸ” Utilisation de ZAP_API_KEY: ${env.ZAP_API_KEY.take(8)}..."

                    # IMPORTANT: ZAP est maintenant dans l'environnement Jenkins, pas ephemere
                    cd rhDemo/infra/jenkins-docker

                    # Nettoyage : supprimer le conteneur ZAP existant s'il existe
                    if docker ps -a --format '{{.Names}}' | grep -q '^rhdemo-jenkins-zap\$'; then
                        echo "ğŸ§¹ Suppression du conteneur ZAP existant..."
                        docker stop rhdemo-jenkins-zap 2>/dev/null || true
                        docker rm rhdemo-jenkins-zap 2>/dev/null || true
                        echo "âœ… Conteneur ZAP supprimÃ©"
                    fi

                    # DÃ©marrage d'un nouveau conteneur ZAP avec la clÃ© API correcte
                    echo "ğŸš€ DÃ©marrage d'un nouveau conteneur ZAP..."
                    echo "   RÃ©seau: rhdemo-jenkins-network"
                    echo "   ClÃ© API: ${env.ZAP_API_KEY.take(8)}..."
                    ZAP_API_KEY=${env.ZAP_API_KEY} docker-compose -f docker-compose.yml -f docker-compose.zap.yml up -d owasp-zap

                    echo "â³ Attente du dÃ©marrage de ZAP (30s max)..."
                    timeout=30
                    while [ \$timeout -gt 0 ]; do
                        if docker exec rhdemo-jenkins-zap curl -f http://localhost:8090/JSON/core/view/version/?apikey=${env.ZAP_API_KEY} >/dev/null 2>&1; then
                            echo "âœ… ZAP dÃ©marrÃ© et accessible"
                            break
                        fi
                        sleep 2
                        timeout=\$((timeout - 2))
                    done

                    if [ \$timeout -le 0 ]; then
                        echo "âŒ Timeout: ZAP n'est pas prÃªt aprÃ¨s 30s"
                        docker logs --tail=20 rhdemo-jenkins-zap
                        exit 1
                    fi

                    echo "ğŸ“Š ZAP Status:"
                    docker exec rhdemo-jenkins-zap curl -s http://localhost:8090/JSON/core/view/version/?apikey=${env.ZAP_API_KEY} | jq .

                    echo ""
                    echo "ğŸ”— Connexion de ZAP au rÃ©seau ephemere..."
                    docker network connect rhdemo-ephemere-network rhdemo-jenkins-zap 2>/dev/null || echo "âš ï¸  ZAP dÃ©jÃ  connectÃ© au rÃ©seau ephemere"

                    echo ""
                    echo "âœ… OWASP ZAP prÃªt Ã  intercepter le trafic Selenium"
                    echo "   Container: rhdemo-jenkins-zap"
                    echo "   RÃ©seau 1: rhdemo-jenkins-network (API + Proxy)"
                    echo "   RÃ©seau 2: rhdemo-ephemere-network (accÃ¨s application via connexion dynamique)"
                    echo "   Port unique (API + Proxy): owasp-zap:8090"
                """
            }
        }

        stage('ğŸŒ Tests Selenium IHM') {
            when {
                allOf {
                    expression { params.DEPLOY_ENV != 'none' }
                    expression { params.RUN_SELENIUM_TESTS == true }
                }
            }
            steps {
                script {
                    echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
                    echo '  PHASE 5 : TESTS FONCTIONNELS'
                    echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
                    echo 'â–¶ ExÃ©cution des tests Selenium sur environnement Docker Compose...'
                }
                
                dir(TEST_PROJECT_PATH) {
                    sh """
                        . \${WORKSPACE}/rhDemo/secrets/env-vars.sh

                        # URLs via nginx dans le rÃ©seau Docker avec HTTPS
                        # Firefox dans Jenkins doit utiliser les network aliases DNS Docker
                        # Car Jenkins container est connectÃ© Ã  rhdemo-ephemere-network
                        # Les aliases rhdemo.ephemere.local et keycloak.ephemere.local sont rÃ©solus via DNS Docker
                        # HTTPS utilisÃ© pour tester en conditions rÃ©elles (certificat auto-signÃ© acceptÃ© par setAcceptInsecureCerts)
                        APP_URL="https://rhdemo.ephemere.local:58443"
                        KEYCLOAK_URL="https://rhdemo.ephemere.local:58443/realms/RHDemo"

                        # Credentials de test (user avec ROLE_consult + ROLE_MAJ pour tester toutes les opÃ©rations)
                        # Ces variables seront passÃ©es via propriÃ©tÃ©s Maven Ã  TestConfig
                        # Username chargÃ© depuis secrets-ephemere.yml (pas de valeur en dur)
                        TEST_USERNAME="\${RHDEMO_TEST_ID_USER_MAJ}"
                        TEST_PASSWORD="\${RHDEMO_TEST_PWD_USER_MAJ}"

                        # Configuration du proxy ZAP pour intercepter le trafic Selenium
                        # BaseSeleniumTest.java dÃ©tecte ces variables et configure le proxy WebDriver
                        export ZAP_PROXY_HOST=owasp-zap
                        export ZAP_PROXY_PORT=8090

                        echo "ğŸ“ Configuration des tests Selenium:"
                        echo "   APP_URL: \${APP_URL}"
                        echo "   KEYCLOAK_URL: \${KEYCLOAK_URL}"
                        echo "   TEST_USERNAME: \${TEST_USERNAME} (ROLE_consult + ROLE_MAJ)"
                        echo "   Mode: Headless"
                        echo "   ZAP Proxy: \${ZAP_PROXY_HOST}:\${ZAP_PROXY_PORT}"
                        echo "   (Healthcheck HTTPS validÃ© avant ce stage)"

                        # Lancement des tests avec TOUTES les configs via propriÃ©tÃ©s Maven
                        # TestConfig charge dans l'ordre: Maven properties > env vars > YAML
                        cd \${WORKSPACE}/rhDemo && ./mvnw clean test -f ../\${TEST_PROJECT_PATH}/pom.xml \\
                            -Dtest.baseurl=\${APP_URL} \\
                            -Dtest.keycloak.url=\${KEYCLOAK_URL} \\
                            -Dselenium.headless=true \\
                            -Dtest.username=\${TEST_USERNAME} \\
                            -Dtest.password=\${TEST_PASSWORD}
                    """
                }
            }
            post {
                always {
                    script {
                        // Archivage des screenshots en cas d'Ã©chec
                        dir(TEST_PROJECT_PATH) {
                            archiveArtifacts artifacts: '**/screenshots/**/*.png', allowEmptyArchive: true
                            junit '**/target/surefire-reports/*.xml'
                        }

                        // GÃ©nÃ©ration du rapport OWASP ZAP avant dÃ©connexion
                        echo 'ğŸ“Š GÃ©nÃ©ration du rapport OWASP ZAP...'
                        sh """#!/bin/bash
                            # Sauvegarder le workspace actuel
                            WORKSPACE_DIR=\$(pwd)

                            # CrÃ©er le rÃ©pertoire pour les rapports ZAP dans le workspace
                            mkdir -p "\${WORKSPACE_DIR}/zap-reports"

                            # Utiliser la clÃ© API ZAP dÃ©finie comme variable d'environnement Jenkins
                            ZAP_API_KEY="${env.ZAP_API_KEY}"
                            ZAP_HOST="owasp-zap"
                            ZAP_PORT="8090"

                            echo "ğŸ” RÃ©cupÃ©ration du rapport ZAP depuis http://\${ZAP_HOST}:\${ZAP_PORT}"
                            echo "   ClÃ© API utilisÃ©e: \${ZAP_API_KEY:0:8}..."

                            # Tester d'abord la connexion Ã  ZAP
                            if curl -s -f "http://\${ZAP_HOST}:\${ZAP_PORT}/JSON/core/view/version/?apikey=\${ZAP_API_KEY}" >/dev/null 2>&1; then
                                echo "âœ… Connexion Ã  ZAP rÃ©ussie"

                                # GÃ©nÃ©rer le rapport HTML
                                if curl -f -o "\${WORKSPACE_DIR}/zap-reports/zap-report.html" \
                                    "http://\${ZAP_HOST}:\${ZAP_PORT}/OTHER/core/other/htmlreport/?apikey=\${ZAP_API_KEY}" 2>&1; then
                                    echo "âœ… Rapport HTML ZAP gÃ©nÃ©rÃ©: \$(du -h \${WORKSPACE_DIR}/zap-reports/zap-report.html | cut -f1)"
                                else
                                    echo "âš ï¸  Ã‰chec de gÃ©nÃ©ration du rapport HTML ZAP"
                                fi

                                # GÃ©nÃ©rer Ã©galement le rapport JSON pour analyse
                                if curl -f -o "\${WORKSPACE_DIR}/zap-reports/zap-report.json" \
                                    "http://\${ZAP_HOST}:\${ZAP_PORT}/JSON/core/view/alerts/?apikey=\${ZAP_API_KEY}" 2>&1; then
                                    ALERT_COUNT=\$(jq '. | length' "\${WORKSPACE_DIR}/zap-reports/zap-report.json" 2>/dev/null || echo "?")
                                    echo "âœ… Rapport JSON ZAP gÃ©nÃ©rÃ©: \${ALERT_COUNT} alertes dÃ©tectÃ©es"
                                else
                                    echo "âš ï¸  Ã‰chec de gÃ©nÃ©ration du rapport JSON ZAP"
                                fi
                            else
                                echo "âŒ Impossible de se connecter Ã  ZAP - VÃ©rifier que ZAP est dÃ©marrÃ© et que la clÃ© API est correcte"
                            fi
                        """

                        // Archiver les rapports ZAP
                        archiveArtifacts artifacts: 'zap-reports/*', fingerprint: true, allowEmptyArchive: true

                        // DÃ©connexion de ZAP du rÃ©seau ephemere aprÃ¨s les tests
                        echo 'ğŸ”Œ DÃ©connexion de ZAP du rÃ©seau ephemere...'
                        sh '''
                            docker network disconnect rhdemo-ephemere-network rhdemo-jenkins-zap 2>/dev/null || echo "âš ï¸  ZAP dÃ©jÃ  dÃ©connectÃ© du rÃ©seau ephemere"
                            echo "âœ… ZAP dÃ©connectÃ© du rÃ©seau ephemere (reste sur jenkins-network)"
                        '''

                        // DÃ©connexion de Jenkins du rÃ©seau ephemere aprÃ¨s les tests
                        echo 'ğŸ”Œ DÃ©connexion de Jenkins du rÃ©seau ephemere...'
                        sh '''#!/bin/bash
                            # Trouver le conteneur Jenkins principal (pas l'agent)
                            JENKINS_CONTAINER=$(docker ps --filter "name=jenkins" --format "{{.Names}}" | grep -v agent | head -n 1)
                            echo "Conteneur Jenkins trouvÃ©: $JENKINS_CONTAINER"

                            if [ -n "$JENKINS_CONTAINER" ]; then
                                docker network disconnect rhdemo-ephemere-network $JENKINS_CONTAINER 2>/dev/null || echo "âš ï¸  Jenkins dÃ©jÃ  dÃ©connectÃ© du rÃ©seau ephemere"
                                echo "âœ… Jenkins ($JENKINS_CONTAINER) dÃ©connectÃ© du rÃ©seau rhdemo-ephemere-network"
                            else
                                echo "âš ï¸ Conteneur Jenkins introuvable pour dÃ©connexion"
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('ğŸ›‘ ArrÃªt App Test') {
            when {
                allOf {
                    expression { params.DEPLOY_ENV != 'none' }
                    expression { params.RUN_SELENIUM_TESTS == true }
                }
            }
            steps {
                script {
                    echo 'â–¶ ArrÃªt de l\'application test...'
                    sh '''
                        if [ -f app-test.container ]; then
                            CONTAINER=$(cat app-test.container)
                            echo "ArrÃªt du container: $CONTAINER"
                            docker stop $CONTAINER 2>/dev/null || echo "âœ… Container dÃ©jÃ  arrÃªtÃ©"
                            docker rm $CONTAINER 2>/dev/null || echo "âœ… Container dÃ©jÃ  supprimÃ©"
                            rm app-test.container
                        else
                            echo "âœ… Pas de container de test Ã  nettoyer"
                        fi
                    '''
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 6 : ARCHIVAGE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        stage('ğŸ“š Archivage Artifacts') {
            steps {
                script {
                    echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
                    echo '  PHASE 6 : ARCHIVAGE'
                    echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
                    echo 'â–¶ Archivage du JAR et des rapports...'
                }
                archiveArtifacts artifacts: "${JAR_FILE}", fingerprint: true
                archiveArtifacts artifacts: '**/target/surefire-reports/**', allowEmptyArchive: true
            }
        }
        
        stage('ğŸ“ GÃ©nÃ©ration Rapports') {
            steps {
                script {
                    echo 'â–¶ Publication des rapports...'

                    // Utilisation de la fonction centralisÃ©e pour publier tous les rapports
                    def lib = load 'rhDemo/vars/rhDemoLib.groovy'

                    def reports = [
                        ['rhDemo/target/site/jacoco', 'index.html', 'Code Coverage (JaCoCo)'],
                        ['trivy-reports', 'nginx.html', 'Trivy - Nginx'],
                        ['trivy-reports', 'postgres.html', 'Trivy - PostgreSQL'],
                        ['trivy-reports', 'keycloak.html', 'Trivy - Keycloak'],
                        ['trivy-reports', 'rhdemo-app.html', 'Trivy - RHDemo App'],
                        ['rhDemo/target', 'dependency-check-report.html', 'OWASP Dependency-Check'],
                        ['zap-reports', 'zap-report.html', 'OWASP ZAP Security Report']
                    ]

                    lib.publishHTMLReports(reports)
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STAGES DE PRODUCTION SUPPRIMÃ‰S
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Les stages de production fictifs ont Ã©tÃ© supprimÃ©s.
        // Utilisez les pipelines dÃ©diÃ©s : Jenkinsfile-CI et Jenkinsfile-CD
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // POST-ACTIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    post {
        always {
            script {
                echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
                echo '  NETTOYAGE ET NOTIFICATIONS'
                echo 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
                
                // Pas de nettoyage DNS nÃ©cessaire: les alias Docker network
                // sont automatiquement supprimÃ©s avec le docker-compose down
                echo 'âœ… RÃ©solution DNS via Docker network aliases (pas de nettoyage nÃ©cessaire)'

                // SÃ‰CURITÃ‰ : Nettoyage des fichiers contenant des secrets
                echo 'â–¶ Nettoyage sÃ©curisÃ© des fichiers de secrets...'
                sh '''
                    # Ã‰craser puis supprimer les fichiers contenant des secrets
                    if [ -f "rhDemo/secrets/env-vars.sh" ]; then
                        # Ã‰craser avec des zÃ©ros avant suppression (sÃ©curitÃ© supplÃ©mentaire)
                        shred -vfz -n 3 rhDemo/secrets/env-vars.sh 2>/dev/null || rm -f rhDemo/secrets/env-vars.sh
                        echo "âœ… env-vars.sh supprimÃ© de maniÃ¨re sÃ©curisÃ©e"
                    fi

                    if [ -f "rhDemo/secrets/secrets-rhdemo.yml" ]; then
                        # Nettoyer aussi le fichier secrets-rhdemo.yml gÃ©nÃ©rÃ© pour rhDemo (contient secrets limitÃ©s)
                        shred -vfz -n 3 rhDemo/secrets/secrets-rhdemo.yml 2>/dev/null || rm -f rhDemo/secrets/secrets-rhdemo.yml
                        echo "âœ… secrets-rhdemo.yml (rhDemo) supprimÃ© de maniÃ¨re sÃ©curisÃ©e"
                    fi

                    if [ -f "${SECRETS_DECRYPTED}" ]; then
                        shred -vfz -n 3 ${SECRETS_DECRYPTED} 2>/dev/null || rm -f ${SECRETS_DECRYPTED}
                        echo "âœ… secrets-decrypted.yml supprimÃ© de maniÃ¨re sÃ©curisÃ©e"
                    fi

                    # Nettoyer aussi le fichier de config Keycloak gÃ©nÃ©rÃ©
                    if [ -f "rhDemoInitKeycloak/src/main/resources/application-ephemere.yml" ]; then
                        shred -vfz -n 3 rhDemoInitKeycloak/src/main/resources/application-ephemere.yml 2>/dev/null || \
                        rm -f rhDemoInitKeycloak/src/main/resources/application-ephemere.yml
                        echo "âœ… application-ephemere.yml supprimÃ© de maniÃ¨re sÃ©curisÃ©e"
                    fi
                '''

                // Conservation de l'environnement Docker Compose pour tests manuels
                if (params.RUN_SELENIUM_TESTS == true) {
                    def buildResult = currentBuild.result ?: 'SUCCESS'

                    if (buildResult != 'SUCCESS') {
                        echo "ğŸ“‹ RÃ©cupÃ©ration des logs Docker (build ${buildResult})..."
                        sh """
                            cd ${EPHEMERE_INFRA_PATH} || exit 0
                            docker-compose -p ${COMPOSE_PROJECT_NAME} logs --tail=100 || true
                        """
                    }

                    echo 'âœ… Environnement ephemere conservÃ© pour tests manuels'
                    echo 'ğŸ“ AccÃ¨s Ã  l\'environnement:'
                    echo '   - Application rhDemo : https://rhdemo.ephemere.local:58443'
                    echo '   - Keycloak Admin     : https://keycloak.ephemere.local:58443'
                    echo ''
                    echo 'ğŸ”§ Commandes utiles:'
                    echo "   - Logs app     : docker logs -f rhdemo-ephemere-app"
                    echo "   - Logs Keycloak: docker logs -f keycloak-ephemere"
                    echo "   - ArrÃªter      : cd ${EPHEMERE_INFRA_PATH} && docker-compose -p ${COMPOSE_PROJECT_NAME} down -v"
                    echo ''
                    echo 'âš ï¸  IMPORTANT: L\'environnement sera automatiquement nettoyÃ© au prochain build'
                    echo '   Le nettoyage se fait en dÃ©but de pipeline (stage "Configuration Environnement Test")'
                }

                echo 'Note: Le nettoyage du workspace et de Docker se fait automatiquement au dÃ©but du prochain build'
            }
        }
        
        success {
            script {
                def deployInfo = params.DEPLOY_ENV != 'none' ? " et deploye en ${params.DEPLOY_ENV}" : ""
                echo "âœ… Pipeline rÃ©ussi${deployInfo} !"
            }
            
            // Email de notification
            emailext(
                subject: "âœ… BUILD SUCCESS - RHDemo API #${env.BUILD_NUMBER}",
                body: """
                    Le build de RHDemo API a rÃ©ussi !
                    
                    Branch: ${env.BRANCH_NAME}
                    Commit: ${env.GIT_COMMIT}
                    DÃ©ploiement: ${params.DEPLOY_ENV}
                    
                    Voir les dÃ©tails: ${env.BUILD_URL}
                """,
                to: "${env.NOTIFICATION_EMAIL}"
            )
        }
        
        failure {
            script {
                echo "âŒ Pipeline Ã©chouÃ© !"
            }
            
            // Email d'alerte
            emailext(
                subject: "âŒ BUILD FAILED - RHDemo API #${env.BUILD_NUMBER}",
                body: """
                    âš ï¸ Le build de RHDemo API a Ã©chouÃ© !
                    
                    Branch: ${env.BRANCH_NAME}
                    Stage: ${env.STAGE_NAME}
                    
                    Voir les logs: ${env.BUILD_URL}console
                """,
                to: "${env.NOTIFICATION_EMAIL}",
                attachLog: true
            )
        }
        
        unstable {
            script {
                echo "âš ï¸ Pipeline instable (tests Ã©chouÃ©s mais build rÃ©ussi)"
            }
        }
    }
}
