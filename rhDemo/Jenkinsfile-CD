/*
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Pipeline CD - RHDemo
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Pipeline de DÃ©ploiement Continu (CD) pour l'application RHDemo
 *
 * OBJECTIF :
 *   - RÃ©cupÃ©rer une image Docker validÃ©e depuis le registry
 *   - La dÃ©ployer sur l'environnement Kubernetes stagingkub
 *   - VÃ©rifier la santÃ© de l'application dÃ©ployÃ©e
 *
 * PRÃ‰-REQUIS :
 *   - Image Docker publiÃ©e sur le registry par le pipeline CI (Jenkinsfile-CI)
 *   - Cluster KinD 'rhdemo' initialisÃ© (via init-stagingkub.sh)
 *   - Namespace 'rhdemo-stagingkub' crÃ©Ã©
 *
 * RÃ‰SULTAT :
 *   - Application RHDemo dÃ©ployÃ©e sur stagingkub
 *   - Services accessibles via Ingress
 *   - Health checks validÃ©s
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

pipeline {
    agent any

    options {
        timeout(time: 30, unit: 'MINUTES')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '50', artifactNumToKeepStr: '10'))
    }

    tools {
        jdk 'JDK21'
        maven 'Maven3'
    }

    environment {
        // Configuration application
        APP_NAME = 'rhdemo-api'
        DOCKER_IMAGE_NAME = "rhdemo-api"

        // Kubernetes
        K8S_NAMESPACE = 'rhdemo-stagingkub'
        K8S_CONTEXT = 'kind-rhdemo'
        CLUSTER_NAME = 'rhdemo'

        // Fichiers de secrets SOPS (stagingkub utilise ses propres secrets, diffÃ©rents de staging Docker Compose)
        SECRETS_FILE = 'rhDemo/secrets/secrets-stagingkub.yml'
        SECRETS_DECRYPTED = 'rhDemo/secrets/secrets-decrypted.yml'
        SECRETS_ENV_VARS = 'rhDemo/secrets/env-vars.sh'
        SECRETS_RHDEMO = 'rhDemo/secrets/secrets-rhdemo.yml'

        // URLs
        APP_URL = 'https://rhdemo.stagingkub.local'
        KEYCLOAK_URL = 'https://keycloak.stagingkub.local'
    }

    parameters {
        string(
            name: 'IMAGE_TAG',
            defaultValue: '',
            description: 'Tag de l\'image Ã  dÃ©ployer (ex: 1.1.0-SNAPSHOT, 1.0.0-rc1). Si vide, utilisera la derniÃ¨re version publiÃ©e.'
        )
        booleanParam(
            name: 'FORCE_RECREATE_PODS',
            defaultValue: false,
            description: 'Forcer la recrÃ©ation des pods (rollout restart)'
        )
        booleanParam(
            name: 'SKIP_HEALTH_CHECK',
            defaultValue: false,
            description: 'Ne pas attendre les health checks (dÃ©ploiement plus rapide mais moins sÃ»r)'
        )
    }

    stages {

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 1 : PRÃ‰PARATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸ› ï¸ Checkout') {
            steps {
                script {
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "  Pipeline CD - RHDemo"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "Build: #${env.BUILD_NUMBER}"
                    echo "Branch: ${env.GIT_BRANCH ?: 'N/A'}"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                }

                // Checkout du code
                checkout scm
            }
        }

        stage('ğŸ”¢ DÃ©terminer Version Image') {
            steps {
                script {
                    if (params.IMAGE_TAG) {
                        // Utiliser le tag fourni en paramÃ¨tre
                        env.DEPLOY_IMAGE_TAG = params.IMAGE_TAG
                        echo "â–¶ Tag fourni en paramÃ¨tre: ${env.DEPLOY_IMAGE_TAG}"
                    } else {
                        // Lire la version depuis pom.xml via Maven
                        echo "â–¶ Aucun tag fourni, lecture depuis pom.xml..."

                        dir('rhDemo') {
                            env.DEPLOY_IMAGE_TAG = sh(
                                script: './mvnw help:evaluate -Dexpression=project.version -q -DforceStdout',
                                returnStdout: true
                            ).trim()
                        }

                        if (!env.DEPLOY_IMAGE_TAG) {
                            error("âŒ Impossible de dÃ©terminer la version de l'image")
                        }

                        echo "â–¶ Version dÃ©tectÃ©e depuis pom.xml: ${env.DEPLOY_IMAGE_TAG}"
                    }

                    echo "âœ… Version de l'image Ã  dÃ©ployer: ${env.DEPLOY_IMAGE_TAG}"
                }
            }
        }

        stage('ğŸ”“ DÃ©chiffrement Secrets SOPS') {
            steps {
                script {
                    echo 'â–¶ VÃ©rification SOPS et YQ...'
                }
                sh '''
                    sops --version
                    yq --version
                '''

                script {
                    echo 'â–¶ DÃ©chiffrement du fichier de secrets...'
                }

                // Utiliser le credential sops-age-key de maniÃ¨re sÃ©curisÃ©e
                withCredentials([file(credentialsId: 'sops-age-key', variable: 'SOPS_AGE_KEY_FILE')]) {
                    sh '''
                        # CrÃ©er le rÃ©pertoire secrets s'il n'existe pas
                        mkdir -p rhDemo/secrets

                        # DÃ©chiffrer le fichier de secrets
                        echo "DÃ©chiffrement de ${SECRETS_FILE}..."
                        sops -d ${SECRETS_FILE} > ${SECRETS_DECRYPTED}

                        # VÃ©rifier que le fichier a Ã©tÃ© dÃ©chiffrÃ©
                        if [ ! -f ${SECRETS_DECRYPTED} ]; then
                            echo "âŒ Ã‰chec du dÃ©chiffrement"
                            exit 1
                        fi

                        echo "âœ… Secrets dÃ©chiffrÃ©s avec succÃ¨s"

                        # Extraire les valeurs pour les variables d'environnement
                        # SÃ‰CURITÃ‰: DÃ©sactiver l'Ã©cho des commandes pour ne pas exposer les secrets dans les logs
                        set +x

                        # Exporter les secrets comme variables d'environnement pour les stages suivants
                        {
                            # PROTECTION: DÃ©sactiver l'Ã©cho pour Ã©viter l'exposition des secrets lors du sourcing
                            echo "# SÃ‰CURITÃ‰: Ce fichier contient des secrets - dÃ©sactive automatiquement le tracing bash"
                            echo "{ set +x; } 2>/dev/null"
                            echo ""

                            echo "export RHDEMO_DATASOURCE_PASSWORD_PG=$(yq eval '.rhdemo.datasource.password.pg' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_DATASOURCE_PASSWORD_H2=$(yq eval '.rhdemo.datasource.password.h2' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET=$(yq eval '.rhdemo.client.registration.keycloak.client.secret' ${SECRETS_DECRYPTED})"

                            # Mots de passe Keycloak pour environnement staging
                            echo "export KEYCLOAK_DB_PASSWORD=$(yq eval '.keycloak.db.password' ${SECRETS_DECRYPTED})"
                            echo "export KEYCLOAK_ADMIN_PASSWORD=$(yq eval '.keycloak.admin.password' ${SECRETS_DECRYPTED})"
                            echo "export KEYCLOAK_ADMIN_USER=$(yq eval '.keycloak.admin.user // \"admin\"' ${SECRETS_DECRYPTED})"
                        } > rhDemo/secrets/env-vars.sh 2>&1

                        # RÃ©activer l'Ã©cho des commandes
                        set -x

                        echo "âœ… Variables d'environnement prÃ©parÃ©es"
                    '''
                }
            }
            post {
                always {
                    script {
                        // Supprimer le fichier dÃ©chiffrÃ© pour la sÃ©curitÃ©
                        sh 'rm -f ${SECRETS_DECRYPTED} || true'
                    }
                }
            }
        }

        stage('ğŸ” Extraction secrets rhDemo') {
            steps {
                script {
                    echo 'â–¶ CrÃ©ation du fichier secrets-rhdemo.yml pour rhDemo...'
                }

                sh '''
                    # SÃ‰CURITÃ‰: DÃ©sactiver l'Ã©cho des commandes
                    set +x

                    # Source les secrets
                    . rhDemo/secrets/env-vars.sh

                    # CrÃ©er le fichier secrets-rhdemo.yml
                    cat > rhDemo/secrets/secrets-rhdemo.yml <<EOF

rhdemo:
  datasource:
    password:
      pg: ${RHDEMO_DATASOURCE_PASSWORD_PG}
      h2: ${RHDEMO_DATASOURCE_PASSWORD_H2}
  client:
    registration:
      keycloak:
        client:
          secret: ${RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET}
EOF

                    # RÃ©activer l'Ã©cho
                    set -x

                    echo "âœ… Fichier secrets-rhdemo.yml crÃ©Ã©"
                '''
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 2 : CONFIGURATION KUBERNETES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('â˜¸ï¸ Configure Kubernetes Access') {
            steps {
                script {
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "  CONFIGURATION DE L'ACCÃˆS KUBERNETES"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "â–¶ Configuration de kubectl pour le cluster KinD..."
                }
                sh """
                    # VÃ©rifier que le cluster KinD existe
                    if ! kind get clusters | grep -q "^${env.CLUSTER_NAME}\$"; then
                        echo "âŒ Cluster KinD '${env.CLUSTER_NAME}' non trouvÃ©"
                        echo "   ExÃ©cutez d'abord: rhDemo/infra/stagingkub/scripts/init-stagingkub.sh"
                        exit 1
                    fi

                    echo "âœ… Cluster KinD '${env.CLUSTER_NAME}' trouvÃ©"

                    # Connecter Jenkins au rÃ©seau kind si nÃ©cessaire
                    JENKINS_CONTAINER=\$(hostname)
                    if ! docker network inspect kind 2>/dev/null | grep -q "\$JENKINS_CONTAINER"; then
                        echo "â–¶ Connexion de Jenkins au rÃ©seau kind..."
                        docker network connect kind \$JENKINS_CONTAINER 2>/dev/null && echo "âœ… Jenkins connectÃ© au rÃ©seau kind" || echo "âš ï¸  Impossible de connecter Jenkins au rÃ©seau kind"
                    else
                        echo "âœ… Jenkins dÃ©jÃ  connectÃ© au rÃ©seau kind"
                    fi

                    # GÃ©nÃ©rer une kubeconfig adaptÃ©e pour Jenkins
                    # Remplace l'adresse localhost par le nom DNS du container control-plane
                    echo "â–¶ GÃ©nÃ©ration de la configuration kubectl..."
                    kind get kubeconfig --name ${env.CLUSTER_NAME} | sed 's|https://127.0.0.1:[0-9]*|https://rhdemo-control-plane:6443|g' > /tmp/kubeconfig-kind

                    # Installer la kubeconfig
                    mkdir -p \$HOME/.kube
                    cp /tmp/kubeconfig-kind \$HOME/.kube/config
                    chmod 600 \$HOME/.kube/config
                    rm /tmp/kubeconfig-kind

                    echo "âœ… Configuration kubectl installÃ©e"

                    # VÃ©rifier l'accÃ¨s au cluster
                    echo "â–¶ VÃ©rification de l'accÃ¨s au cluster..."
                    if kubectl cluster-info 2>&1 | grep -q "is running"; then
                        echo "âœ… AccÃ¨s au cluster KinD confirmÃ©"
                        kubectl config use-context ${env.K8S_CONTEXT}
                        echo "âœ… Contexte '${env.K8S_CONTEXT}' activÃ©"
                    else
                        echo "âŒ Impossible d'accÃ©der au cluster KinD"
                        echo "   Logs de dÃ©bogage:"
                        kubectl cluster-info || true
                        exit 1
                    fi
                """
            }
        }

        stage('ğŸ³ VÃ©rification Image Registry') {
            steps {
                script {
                    echo "â–¶ VÃ©rification de l'image dans le registry..."
                }
                sh """
                    # DÃ©tection du registry sur le port 5000
                    REGISTRY_NAME=\$(docker ps --filter "publish=5000" --format '{{.Names}}' | head -n 1)

                    if [ -z "\$REGISTRY_NAME" ]; then
                        echo "âŒ Aucun registry actif sur le port 5000"

                        # Chercher un registry existant (mÃªme arrÃªtÃ©)
                        EXISTING_REGISTRY=\$(docker ps -a --filter "publish=5000" --format '{{.Names}}' | head -n 1)

                        if [ -n "\$EXISTING_REGISTRY" ]; then
                            echo "â–¶ Registry trouvÃ© mais arrÃªtÃ©: \$EXISTING_REGISTRY"
                            echo "  DÃ©marrage du registry..."
                            docker start \$EXISTING_REGISTRY
                            REGISTRY_NAME="\$EXISTING_REGISTRY"
                            sleep 2
                        else
                            echo "âŒ Aucun registry Docker trouvÃ©"
                            echo "   CrÃ©ez d'abord un registry ou exÃ©cutez le pipeline CI"
                            exit 1
                        fi
                    fi

                    echo "âœ… Registry dÃ©tectÃ©: \$REGISTRY_NAME"

                    # VÃ©rifier que l'image existe dans le registry
                    REGISTRY_URL="http://\$REGISTRY_NAME:5000"

                    echo "â–¶ VÃ©rification de l'image ${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG}..."

                    if curl -sf \$REGISTRY_URL/v2/${env.DOCKER_IMAGE_NAME}/tags/list | grep -q "${env.DEPLOY_IMAGE_TAG}"; then
                        echo "âœ… Image trouvÃ©e dans le registry"
                    else
                        echo "âŒ Image ${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG} introuvable dans le registry"
                        echo ""
                        echo "   Tags disponibles pour ${env.DOCKER_IMAGE_NAME}:"
                        curl -s \$REGISTRY_URL/v2/${env.DOCKER_IMAGE_NAME}/tags/list || echo "   Aucun tag trouvÃ©"
                        echo ""
                        echo "   ExÃ©cutez d'abord le pipeline CI pour construire et publier l'image"
                        exit 1
                    fi
                """
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 3 : MISE Ã€ JOUR DES SECRETS KUBERNETES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('â˜¸ï¸ Update Kubernetes Secrets') {
            steps {
                script {
                    echo "â–¶ Mise Ã  jour des secrets Kubernetes..."
                }
                sh """
                    # SÃ‰CURITÃ‰: DÃ©sactiver l'Ã©cho des commandes pour ne pas exposer les secrets
                    set +x

                    # Charger les secrets depuis SOPS
                    . rhDemo/secrets/env-vars.sh

                    # Utiliser le contexte KinD
                    kubectl config use-context ${env.K8S_CONTEXT}

                    # Mettre Ã  jour les secrets Kubernetes
                    kubectl create secret generic rhdemo-db-secret \\
                      --from-literal=password="\${RHDEMO_DATASOURCE_PASSWORD_PG}" \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    kubectl create secret generic keycloak-db-secret \\
                      --from-literal=password="\${KEYCLOAK_DB_PASSWORD}" \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    kubectl create secret generic keycloak-admin-secret \\
                      --from-literal=password="\${KEYCLOAK_ADMIN_PASSWORD}" \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    # Mettre Ã  jour le secret pour secrets-rhdemo.yml
                    kubectl create secret generic rhdemo-app-secrets \\
                      --from-file=secrets-rhdemo.yml=rhDemo/secrets/secrets-rhdemo.yml \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    # RÃ©activer l'Ã©cho
                    set -x

                    echo "âœ… Secrets Kubernetes mis Ã  jour"
                """
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 4 : DÃ‰PLOIEMENT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('â˜¸ï¸ Deploy to Kubernetes') {
            steps {
                script {
                    def registryName = sh(script: 'docker ps --filter "publish=5000" --format "{{.Names}}" | head -n 1', returnStdout: true).trim()

                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "  DÃ‰PLOIEMENT KUBERNETES (STAGINGKUB)"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "â–¶ DÃ©ploiement avec Helm..."
                    echo "   Chart: rhDemo/infra/stagingkub/helm/rhdemo"
                    echo "   Registry: ${registryName}"
                    echo "   Image: ${registryName}:5000/${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG}"
                    echo "   Namespace: ${env.K8S_NAMESPACE}"
                }
                sh """
                    # Utiliser le contexte KinD
                    kubectl config use-context ${env.K8S_CONTEXT}

                    # DÃ©ployer ou mettre Ã  jour avec Helm
                    # IMPORTANT: Pour KinD, utiliser localhost:5000 qui est mirrorÃ© vers le registry
                    # Note: Le namespace doit dÃ©jÃ  exister (crÃ©Ã© par init-stagingkub.sh)
                    helm upgrade --install rhdemo rhDemo/infra/stagingkub/helm/rhdemo \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --set rhdemo.image.repository=localhost:5000/${env.DOCKER_IMAGE_NAME} \\
                      --set rhdemo.image.tag=${env.DEPLOY_IMAGE_TAG} \\
                      --wait \\
                      --timeout 10m

                    echo ""
                    echo "âœ… DÃ©ploiement Helm rÃ©ussi"
                """
            }
        }

        stage('ğŸ—„ï¸ Initialize Database Schema') {
            steps {
                script {
                    echo "â–¶ Initialisation du schÃ©ma de la base de donnÃ©es..."
                }
                sh """
                    kubectl config use-context ${env.K8S_CONTEXT}

                    # Attendre que PostgreSQL soit prÃªt
                    kubectl wait --for=condition=ready pod -l app=postgresql-rhdemo \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --timeout=5m

                    # VÃ©rifier si la table 'employes' existe dÃ©jÃ 
                    TABLE_EXISTS=\$(kubectl exec -i postgresql-rhdemo-0 -n ${env.K8S_NAMESPACE} -- \\
                      psql -U rhdemo -d rhdemo -tAc "SELECT COUNT(*) FROM information_schema.tables WHERE table_name='employes'")

                    if [ "\$TABLE_EXISTS" = "0" ]; then
                        echo "â–¶ Table 'employes' non trouvÃ©e, initialisation du schÃ©ma..."
                        kubectl exec -i postgresql-rhdemo-0 -n ${env.K8S_NAMESPACE} -- \\
                          psql -U rhdemo -d rhdemo < ../rhDemo/pgschema.sql
                        echo "âœ… SchÃ©ma de base de donnÃ©es initialisÃ©"
                    else
                        echo "â„¹ï¸  Table 'employes' existe dÃ©jÃ , pas d'initialisation nÃ©cessaire"
                    fi
                """
            }
        }

        stage('ğŸ”„ Force Pods Restart') {
            when {
                expression { params.FORCE_RECREATE_PODS == true }
            }
            steps {
                script {
                    echo "â–¶ RedÃ©marrage forcÃ© des pods..."
                }
                sh """
                    kubectl config use-context ${env.K8S_CONTEXT}

                    # Rollout restart pour forcer le redÃ©marrage des pods
                    kubectl rollout restart deployment/rhdemo -n ${env.K8S_NAMESPACE} || true
                    kubectl rollout restart statefulset/postgresql-rhdemo -n ${env.K8S_NAMESPACE} || true
                    kubectl rollout restart statefulset/postgresql-keycloak -n ${env.K8S_NAMESPACE} || true
                    kubectl rollout restart deployment/keycloak -n ${env.K8S_NAMESPACE} || true

                    echo "âœ… Pods redÃ©marrÃ©s"
                """
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 5 : VÃ‰RIFICATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('â˜¸ï¸ Wait for Kubernetes Readiness') {
            when {
                expression { params.SKIP_HEALTH_CHECK == false }
            }
            steps {
                script {
                    echo "â–¶ Attente de la disponibilitÃ© des services..."
                }
                sh """
                    kubectl config use-context ${env.K8S_CONTEXT}

                    # Attendre que tous les pods soient prÃªts
                    echo "â–¶ Attente des pods..."
                    kubectl wait --for=condition=ready pod --all \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --timeout=10m || {
                        echo "âš ï¸  Certains pods ne sont pas prÃªts aprÃ¨s 10 minutes"
                        echo "   Ã‰tat actuel des pods:"
                        kubectl get pods -n ${env.K8S_NAMESPACE}
                        echo ""
                        echo "   Logs des pods en erreur:"
                        kubectl get pods -n ${env.K8S_NAMESPACE} --field-selector=status.phase!=Running -o name | xargs -I {} kubectl logs {} -n ${env.K8S_NAMESPACE} --tail=50 || true
                        exit 1
                    }

                    echo "âœ… Tous les pods sont prÃªts"
                """
            }
        }

        stage('ğŸ¥ Health Checks') {
            when {
                expression { params.SKIP_HEALTH_CHECK == false }
            }
            steps {
                script {
                    echo "â–¶ VÃ©rification de la santÃ© des services..."
                }
                sh """
                    kubectl config use-context ${env.K8S_CONTEXT}

                    echo "â–¶ VÃ©rification de l'application RHDemo..."
                    # RÃ©cupÃ©rer le nom du pod rhdemo (label app=rhdemo-app)
                    RHDEMO_POD=\$(kubectl get pods -n ${env.K8S_NAMESPACE} -l app=rhdemo-app -o jsonpath='{.items[0].metadata.name}')

                    if [ -z "\$RHDEMO_POD" ]; then
                        echo "âŒ Aucun pod rhdemo trouvÃ©"
                        kubectl get pods -n ${env.K8S_NAMESPACE} --show-labels
                        exit 1
                    fi

                    echo "   Pod: \$RHDEMO_POD"

                    # VÃ©rifier l'actuator health
                    if kubectl exec \$RHDEMO_POD -n ${env.K8S_NAMESPACE} -- curl -sf http://localhost:9000/actuator/health > /dev/null 2>&1; then
                        echo "âœ… Application RHDemo : healthy"
                    else
                        echo "âŒ Application RHDemo : unhealthy"
                        echo "   Logs du pod:"
                        kubectl logs \$RHDEMO_POD -n ${env.K8S_NAMESPACE} --tail=50
                        exit 1
                    fi

                    echo ""
                    echo "â–¶ VÃ©rification de Keycloak..."
                    KEYCLOAK_POD=\$(kubectl get pods -n ${env.K8S_NAMESPACE} -l app=keycloak -o jsonpath='{.items[0].metadata.name}')

                    if [ -z "\$KEYCLOAK_POD" ]; then
                        echo "âš ï¸  Aucun pod Keycloak trouvÃ©"
                    else
                        echo "   Pod: \$KEYCLOAK_POD"

                        if kubectl exec \$KEYCLOAK_POD -n ${env.K8S_NAMESPACE} -- curl -sf http://localhost:9000/health/ready > /dev/null 2>&1; then
                            echo "âœ… Keycloak : ready"
                        else
                            echo "âš ï¸  Keycloak : not ready"
                            kubectl logs \$KEYCLOAK_POD -n ${env.K8S_NAMESPACE} --tail=30 || true
                        fi
                    fi

                    echo ""
                    echo "â–¶ VÃ©rification de PostgreSQL RHDemo..."
                    PG_RHDEMO_POD=\$(kubectl get pods -n ${env.K8S_NAMESPACE} -l app=postgresql-rhdemo -o jsonpath='{.items[0].metadata.name}')

                    if [ -z "\$PG_RHDEMO_POD" ]; then
                        echo "âš ï¸  Aucun pod PostgreSQL RHDemo trouvÃ©"
                    else
                        echo "   Pod: \$PG_RHDEMO_POD"

                        if kubectl exec \$PG_RHDEMO_POD -n ${env.K8S_NAMESPACE} -- pg_isready -U rhdemo > /dev/null 2>&1; then
                            echo "âœ… PostgreSQL RHDemo : ready"
                        else
                            echo "âš ï¸  PostgreSQL RHDemo : not ready"
                        fi
                    fi

                    echo ""
                    echo "âœ… Health checks terminÃ©s"
                """
            }
        }

        stage('ğŸ“Š Deployment Status') {
            steps {
                script {
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "  Ã‰TAT DU DÃ‰PLOIEMENT"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                }
                sh """
                    kubectl config use-context ${env.K8S_CONTEXT}

                    echo "ğŸ“Š Statut des pods:"
                    kubectl get pods -n ${env.K8S_NAMESPACE} -o wide

                    echo ""
                    echo "ğŸ”— Services:"
                    kubectl get svc -n ${env.K8S_NAMESPACE}

                    echo ""
                    echo "ğŸŒ Ingress:"
                    kubectl get ingress -n ${env.K8S_NAMESPACE}

                    echo ""
                    echo "ğŸ“¦ Images dÃ©ployÃ©es:"
                    kubectl get pods -n ${env.K8S_NAMESPACE} -o jsonpath='{range .items[*]}{.metadata.name}{"\\t"}{.spec.containers[*].image}{"\\n"}{end}'

                    echo ""
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "âœ… DÃ‰PLOIEMENT RÃ‰USSI"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo ""
                    echo "ğŸŒ URLs d'accÃ¨s:"
                    echo "   Application: ${env.APP_URL}"
                    echo "   Keycloak: ${env.KEYCLOAK_URL}"
                    echo ""
                    echo "ğŸ“Œ Image dÃ©ployÃ©e: ${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG}"
                    echo ""
                """
            }
        }

    } // fin stages

    post {
        always {
            script {
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo "Pipeline CD terminÃ©: ${currentBuild.currentResult}"
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

                // Supprimer les fichiers de secrets
                sh """
                    rm -f ${env.SECRETS_DECRYPTED} 2>/dev/null || true
                    rm -f ${env.SECRETS_ENV_VARS} 2>/dev/null || true
                    rm -f ${env.SECRETS_RHDEMO} 2>/dev/null || true
                """

                echo "âœ… Nettoyage terminÃ©"
            }
        }
        success {
            script {
                echo "âœ… DÃ©ploiement rÃ©ussi !"
                echo ""
                echo "ğŸ“Œ Image dÃ©ployÃ©e: ${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG}"
                echo "ğŸŒ Application accessible: ${env.APP_URL}"
                echo "ğŸ”‘ Keycloak accessible: ${env.KEYCLOAK_URL}"
                echo ""
                echo "Pour vÃ©rifier l'Ã©tat:"
                echo "   kubectl get pods -n ${env.K8S_NAMESPACE}"
                echo "   kubectl logs -f deployment/rhdemo -n ${env.K8S_NAMESPACE}"
            }
        }
        failure {
            script {
                echo "âŒ DÃ©ploiement Ã©chouÃ© !"
                echo "Consultez les logs pour plus de dÃ©tails:"
                echo "   kubectl get pods -n ${env.K8S_NAMESPACE}"
                echo "   kubectl describe pods -n ${env.K8S_NAMESPACE}"
                echo "   kubectl logs -n ${env.K8S_NAMESPACE} <pod-name>"
            }
        }
    }
}
