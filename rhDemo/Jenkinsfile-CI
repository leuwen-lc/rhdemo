/*
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Pipeline CI - RHDemo
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Pipeline d'IntÃ©gration Continue (CI) pour l'application RHDemo
 *
 * OBJECTIF :
 *   - Compiler et construire l'application (Backend + Frontend)
 *   - ExÃ©cuter les tests unitaires et d'intÃ©gration
 *   - Analyser la qualitÃ© du code (SonarQube, OWASP)
 *   - CrÃ©er l'image Docker
 *   - Tester l'application dans un environnement ephemere Docker Compose
 *   - ExÃ©cuter les tests Selenium et OWASP ZAP
 *   - Publier l'image Docker validÃ©e sur le registry
 *
 * RÃ‰SULTAT :
 *   - Image Docker taggÃ©e et publiÃ©e : rhdemo-api:<VERSION>
 *   - Artifacts et rapports archivÃ©s
 *   - PrÃªte pour le dÃ©ploiement CD
 *
 * DÃ‰PLOIEMENT :
 *   - Pour dÃ©ployer sur Kubernetes stagingkub, utilisez le pipeline Jenkinsfile-CD
 *
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

pipeline {
    agent any

    options {
        timeout(time: 2, unit: 'HOURS')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '30', artifactNumToKeepStr: '10'))
    }

    tools {
        jdk 'JDK21'
        maven 'Maven3'
    }

    environment {
        // Configuration application
        APP_NAME = 'rhdemo-api'
        DOCKER_IMAGE_NAME = "rhdemo-api"

        // Configuration Docker
        NGINX_IMAGE = "nginx:1.29.4-alpine"
        POSTGRES_IMAGE = "postgres:16-alpine"
        KEYCLOAK_IMAGE = "quay.io/keycloak/keycloak:26.4.2"

        // Configuration des tests
        TEST_PORT = '9000'
        TEST_PROJECT_PATH = 'rhDemoAPITestIHM'

        // Fichiers de secrets SOPS
        SECRETS_FILE = 'rhDemo/secrets/secrets-ephemere.yml'
        SECRETS_DECRYPTED = 'rhDemo/secrets/secrets-decrypted.yml'
        SECRETS_ENV_VARS = 'rhDemo/secrets/env-vars.sh'
        SECRETS_RHDEMO = 'rhDemo/secrets/secrets-rhdemo.yml'

        // Configuration environnement ephemere (Docker Compose)
        EPHEMERE_INFRA_PATH = 'rhDemo/infra/ephemere'
        KEYCLOAK_INIT_PATH = 'rhDemoInitKeycloak'
        TEST_DOMAIN = 'rhdemo.ephemere.local'
        KEYCLOAK_DOMAIN = 'keycloak.ephemere.local'
        COMPOSE_PROJECT_NAME = "rhdemo-ephemere-${env.BUILD_NUMBER}"

        // Noms des conteneurs Docker
        CONTAINER_NGINX = 'rhdemo-ephemere-nginx'
        CONTAINER_APP = 'rhdemo-ephemere-app'
        CONTAINER_KEYCLOAK = 'keycloak-ephemere'
        CONTAINER_KEYCLOAK_DB = 'keycloak-ephemere-db'
        CONTAINER_DB = 'rhdemo-ephemere-db'
        CONTAINER_ZAP = 'rhdemo-jenkins-zap'

        // Noms des rÃ©seaux Docker
        NETWORK_EPHEMERE = 'rhdemo-ephemere-network'
        NETWORK_JENKINS = 'rhdemo-jenkins-network'
    }

    parameters {
        booleanParam(name: 'RUN_SELENIUM_TESTS', defaultValue: true, description: 'ExÃ©cuter les tests Selenium')
        booleanParam(name: 'RUN_SONAR', defaultValue: true, description: 'ExÃ©cuter l\'analyse SonarQube')
        booleanParam(name: 'PUBLISH_IMAGE', defaultValue: true, description: 'Publier l\'image sur le registry aprÃ¨s validation')
        booleanParam(name: 'KEEP_EPHEMERE_ENV', defaultValue: false, description: 'Garder l\'environnement ephemere pour debug (ne pas nettoyer Ã  la fin)')
        string(name: 'IMAGE_TAG_SUFFIX', defaultValue: '', description: 'Suffixe optionnel pour le tag (ex: -rc1, -hotfix)')
    }

    stages {

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 1 : PRÃ‰PARATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸ› ï¸ Checkout') {
            steps {
                script {
                    // Charger la bibliothÃ¨que
                    def lib = load 'rhDemo/vars/rhDemoLib.groovy'

                    lib.printSectionHeader("Pipeline CI - RHDemo")
                    echo "Build: #${env.BUILD_NUMBER}"
                    echo "Branch: ${env.GIT_BRANCH ?: 'N/A'}"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                }

                // Checkout du code
                checkout scm
                sh 'git log -1 --pretty=format:"%h - %an : %s"'

                script {
                    echo 'â–¶ VÃ©rification des projets dans le workspace...'
                    // rhDemoInitKeycloak et rhDemoAPITestIHM sont dans le MÃŠME repo que rhDemo
                    // Le checkout SCM rÃ©cupÃ¨re tout le workspace (un seul .git Ã  la racine)
                }

                sh '''
                    echo "â–¶ VÃ©rification rhDemoInitKeycloak..."
                    if [ -d "rhDemoInitKeycloak" ]; then
                        echo "âœ… rhDemoInitKeycloak trouvÃ©"
                    else
                        echo "âŒ rhDemoInitKeycloak introuvable"
                        exit 1
                    fi

                    echo "â–¶ VÃ©rification rhDemoAPITestIHM..."
                    if [ -d "rhDemoAPITestIHM" ]; then
                        echo "âœ… rhDemoAPITestIHM trouvÃ©"
                    else
                        echo "âŒ rhDemoAPITestIHM introuvable"
                        exit 1
                    fi

                    echo ""
                    echo "âœ… Tous les projets du repository sont prÃ©sents"
                '''
            }
        }

        stage('ğŸ”¢ Lecture Version Maven') {
            steps {
                script {
                    echo "â–¶ Lecture de la version depuis pom.xml..."

                    // Lire la version depuis le pom.xml avec Maven (mÃ©thode robuste)
                    env.APP_VERSION = sh(
                        script: 'cd rhDemo && ./mvnw help:evaluate -Dexpression=project.version -q -DforceStdout',
                        returnStdout: true
                    ).trim()

                    // VÃ©rifier que la lecture a rÃ©ussi
                    if (!env.APP_VERSION || env.APP_VERSION == '') {
                        error("âŒ Impossible de lire la version depuis pom.xml")
                    }

                    // Construire le nom du fichier JAR avec la version lue
                    env.JAR_FILE = "rhDemo/target/rhdemoAPI-${env.APP_VERSION}.jar"

                    // Mettre Ã  jour les variables Docker
                    env.DOCKER_IMAGE_TAG = env.APP_VERSION

                    // Construire le nom complet de l'image Docker avec version-buildnumber
                    env.RHDEMO_IMAGE = "${env.DOCKER_IMAGE_NAME}:${env.APP_VERSION}-${env.BUILD_NUMBER}"

                    echo "âœ… Version Maven dÃ©tectÃ©e: ${env.APP_VERSION}"
                    echo "   JAR attendu: ${env.JAR_FILE}"
                    echo "   Docker tag: ${env.DOCKER_IMAGE_TAG}"
                    echo "   Image Docker complÃ¨te: ${env.RHDEMO_IMAGE}"
                }
            }
        }

        stage('ğŸ”‘ Initialisation Variables Dynamiques') {
            steps {
                script {
                    echo 'â–¶ Initialisation des variables dynamiques...'

                    // GÃ©nÃ©ration d'une clÃ© API ZAP alÃ©atoire pour la session
                    def zapApiKey = sh(
                        script: 'cat /dev/urandom | tr -dc \'a-zA-Z0-9\' | fold -w 32 | head -n 1',
                        returnStdout: true
                    ).trim()

                    // Stocker comme variable d'environnement globale du pipeline
                    env.ZAP_API_KEY = zapApiKey
                    echo "âœ… ClÃ© API ZAP gÃ©nÃ©rÃ©e: ${zapApiKey.take(8)}..."
                }
            }
        }

        stage('ğŸ”“ DÃ©chiffrement Secrets SOPS') {
            steps {
                script {
                    echo 'â–¶ VÃ©rification SOPS et YQ...'
                }
                sh '''
                    sops --version
                    yq --version
                '''

                script {
                    echo 'â–¶ DÃ©chiffrement du fichier de secrets...'
                }

                // Utiliser le credential sops-age-key de maniÃ¨re sÃ©curisÃ©e
                withCredentials([file(credentialsId: 'sops-age-key', variable: 'SOPS_AGE_KEY_FILE')]) {
                    sh '''
                        # CrÃ©er le rÃ©pertoire secrets s'il n'existe pas
                        mkdir -p rhDemo/secrets

                        # DÃ©chiffrer le fichier de secrets
                        echo "DÃ©chiffrement de ${SECRETS_FILE}..."
                        sops -d ${SECRETS_FILE} > ${SECRETS_DECRYPTED}

                        # VÃ©rifier que le fichier a Ã©tÃ© dÃ©chiffrÃ©
                        if [ ! -f ${SECRETS_DECRYPTED} ]; then
                            echo "âŒ Ã‰chec du dÃ©chiffrement"
                            exit 1
                        fi

                        echo "âœ… Secrets dÃ©chiffrÃ©s avec succÃ¨s"

                        # Extraire les valeurs pour les variables d'environnement
                        # SÃ‰CURITÃ‰: DÃ©sactiver l'Ã©cho des commandes pour ne pas exposer les secrets dans les logs
                        set +x

                        # Exporter les secrets comme variables d'environnement pour les stages suivants
                        # Utilisation de substitution de variables sans affichage dans stdout
                        {
                            # PROTECTION: DÃ©sactiver l'Ã©cho pour Ã©viter l'exposition des secrets lors du sourcing
                            echo "# SÃ‰CURITÃ‰: Ce fichier contient des secrets - dÃ©sactive automatiquement le tracing bash"
                            echo "# DÃ©sactiver le tracing pour ne pas logger les secrets"
                            echo "{ set +x; } 2>/dev/null"
                            echo ""

                            echo "export RHDEMO_DATASOURCE_PASSWORD_PG=$(yq eval '.rhdemo.datasource.password.pg' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_DATASOURCE_PASSWORD_H2=$(yq eval '.rhdemo.datasource.password.h2' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET=$(yq eval '.rhdemo.client.registration.keycloak.client.secret' ${SECRETS_DECRYPTED})"

                            # Mots de passe Keycloak pour environnement ephemere
                            echo "export KEYCLOAK_DB_PASSWORD=$(yq eval '.keycloak.db.password' ${SECRETS_DECRYPTED})"
                            echo "export KEYCLOAK_ADMIN_PASSWORD=$(yq eval '.keycloak.admin.password' ${SECRETS_DECRYPTED})"
                            echo "export KEYCLOAK_ADMIN_USER=$(yq eval '.keycloak.admin.user // \"admin\"' ${SECRETS_DECRYPTED})"

                            # Utilisateurs et mots de passe de test (chiffrÃ©s dans SOPS)
                            echo "export RHDEMO_TEST_ID_USER_ADMIN=$(yq eval '.rhdemo.test.iduseradmin' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_TEST_PWD_USER_ADMIN=$(yq eval '.rhdemo.test.pwduseradmin' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_TEST_ID_USER_MAJ=$(yq eval '.rhdemo.test.idusermaj' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_TEST_PWD_USER_MAJ=$(yq eval '.rhdemo.test.pwdusermaj' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_TEST_ID_USER_CONSULT=$(yq eval '.rhdemo.test.iduserconsult' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_TEST_PWD_USER_CONSULT=$(yq eval '.rhdemo.test.pwduserconsult' ${SECRETS_DECRYPTED})"

                            # URLs des serveurs si elles existent
                            if yq eval '.rhdemo.servers.ephemere' ${SECRETS_DECRYPTED} > /dev/null 2>&1; then
                                echo "export EPHEMERE_SERVER=$(yq eval '.rhdemo.servers.ephemere' ${SECRETS_DECRYPTED})"
                            fi

                            if yq eval '.rhdemo.servers.production' ${SECRETS_DECRYPTED} > /dev/null 2>&1; then
                                echo "export PROD_SERVER=$(yq eval '.rhdemo.servers.production' ${SECRETS_DECRYPTED})"
                            fi
                        } > rhDemo/secrets/env-vars.sh 2>&1

                        # RÃ©activer l'Ã©cho des commandes
                        set -x

                        # Afficher (sans montrer les valeurs)
                        echo "âœ… Variables d'environnement prÃ©parÃ©es"
                    '''
                }
            }
            post {
                always {
                    script {
                        // Supprimer le fichier dÃ©chiffrÃ© pour la sÃ©curitÃ©
                        sh 'rm -f ${SECRETS_DECRYPTED} || true'
                    }
                }
            }
        }

        stage('ğŸ” Extraction secrets rhDemo') {
            steps {
                script {
                    echo 'â–¶ CrÃ©ation du fichier secrets-rhdemo.yml pour rhDemo (uniquement les secrets nÃ©cessaires)...'
                }

                sh '''
                    # SÃ‰CURITÃ‰: DÃ©sactiver l'Ã©cho des commandes
                    set +x

                    # Source les secrets
                    . rhDemo/secrets/env-vars.sh

                    # CrÃ©er un fichier secrets-rhdemo.yml contenant UNIQUEMENT les secrets rhDemo
                    # Ce fichier sera montÃ© dans le container Docker de rhDemo
                    cat > rhDemo/secrets/secrets-rhdemo.yml <<EOF

rhdemo:
  datasource:
    password:
      pg: ${RHDEMO_DATASOURCE_PASSWORD_PG}
      h2: ${RHDEMO_DATASOURCE_PASSWORD_H2}
  client:
    registration:
      keycloak:
        client:
          secret: ${RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET}
EOF

                    # RÃ©activer l'Ã©cho
                    set -x

                    echo "âœ… Fichier rhDemo/secrets/secrets-rhdemo.yml crÃ©Ã© (secrets limitÃ©s Ã  rhDemo uniquement)"
                '''
            }
        }

        stage('ğŸ”§ Configuration rhDemoInitKeycloak') {
            steps {
                script {
                    echo 'â–¶ GÃ©nÃ©ration de application-ephemere.yml pour rhDemoInitKeycloak...'
                    echo '   (Sera utilisÃ© directement via mvnw spring-boot:run, sans packaging JAR)'
                }

                sh '''
                    # Variable TEST_DOMAIN disponible via env.TEST_DOMAIN (dÃ©fini dans environment block)
                    # Pas besoin de la redÃ©finir, elle est automatiquement accessible en bash
                    echo "ğŸ” TEST_DOMAIN: ${TEST_DOMAIN}"

                    # SÃ‰CURITÃ‰: DÃ©sactiver l'Ã©cho des commandes pour ne pas exposer les secrets
                    set +x

                    # Source les secrets dÃ©chiffrÃ©s
                    . rhDemo/secrets/env-vars.sh

                    # GÃ©nÃ©rer application-ephemere.yml (sera utilisÃ© directement par Maven)
                    # NOTE: set +x reste actif pendant la gÃ©nÃ©ration pour ne pas logger les secrets
                    CONFIG_FILE="rhDemoInitKeycloak/src/main/resources/application-ephemere.yml"

                    # IMPORTANT: Sans guillemets sur YMLEOF pour que bash substitue les variables
                    cat > "${CONFIG_FILE}" << YMLEOF
# ========================================
# Configuration Keycloak Server - EPHEMERE
# GÃ©nÃ©rÃ©e automatiquement par Jenkins CI/CD
# ========================================
keycloak:
  # URL interne HTTP pour rhDemoInitKeycloak (exÃ©cutÃ© dans le rÃ©seau Docker)
  # Pas besoin de HTTPS car communication interne sÃ©curisÃ©e par le rÃ©seau isolÃ©
  server-url: http://keycloak-ephemere:8080

  admin:
    realm: master
    username: ${KEYCLOAK_ADMIN_USER}
    password: ${KEYCLOAK_ADMIN_PASSWORD}

  # ========================================
  # Configuration du Realm RHDemo
  # ========================================
  realm:
    name: RHDemo
    display-name: RHDemo Application
    enabled: true
    registration-allowed: false
    registration-email-as-username: false
    reset-password-allowed: true
    edit-username-allowed: false
    login-with-email-allowed: true
    duplicate-emails-allowed: false
    remember-me: true
    sso-session-idle-timeout: 1800
    sso-session-max-lifespan: 36000
    access-token-lifespan: 300

  # ========================================
  # Configuration du Client RHDemo
  # ========================================
  client:
    client-id: RHDemo
    name: RHDemo
    secret: ${RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET}
    root-url: https://${TEST_DOMAIN}:58443/
    base-url: ''
    admin-url: ''
    redirect-uris:
      - https://${TEST_DOMAIN}:58443/*
      - https://rhdemo.ephemere.local:58443/*
      - https://keycloak.ephemere.local:58443/*
      - http://localhost:9000/*
    web-origins:
      - https://${TEST_DOMAIN}:58443
      - https://rhdemo.ephemere.local:58443
      - https://keycloak.ephemere.local:58443
      - http://localhost:9000
    roles:
      - ROLE_admin
      - ROLE_consult
      - ROLE_MAJ

  # ========================================
  # Configuration des Utilisateurs de test
  # ========================================
  users:
    - username: ${RHDEMO_TEST_ID_USER_ADMIN}
      password: ${RHDEMO_TEST_PWD_USER_ADMIN}
      email: ${RHDEMO_TEST_ID_USER_ADMIN}@rhdemo.local
      first-name: Admin
      last-name: RHDemo
      roles:
        - ROLE_admin

    - username: ${RHDEMO_TEST_ID_USER_CONSULT}
      password: ${RHDEMO_TEST_PWD_USER_CONSULT}
      email: ${RHDEMO_TEST_ID_USER_CONSULT}@rhdemo.local
      first-name: Jean
      last-name: Consultant
      roles:
        - ROLE_consult

    - username: ${RHDEMO_TEST_ID_USER_MAJ}
      password: ${RHDEMO_TEST_PWD_USER_MAJ}
      email: ${RHDEMO_TEST_ID_USER_MAJ}@rhdemo.local
      first-name: Marie
      last-name: Manager
      roles:
        - ROLE_consult
        - ROLE_MAJ
YMLEOF

                    # RÃ©activer l'Ã©cho maintenant que les secrets ont Ã©tÃ© Ã©crits dans le fichier
                    set -x

                    echo "âœ… Fichier de configuration Keycloak gÃ©nÃ©rÃ©: ${CONFIG_FILE}"
                    echo "   Ce fichier sera utilisÃ© par rhDemoInitKeycloak pour initialiser Keycloak"
                    echo "   Redirect URIs configurÃ©s pour:"
                    echo "     - https://${TEST_DOMAIN}:58443/*"
                    echo "     - https://rhdemo.ephemere.local:58443/* (pour Selenium/ZAP)"

                    echo ""
                    echo "ğŸ” VÃ©rification de la section redirect-uris dans le fichier gÃ©nÃ©rÃ©:"
                    grep -A 5 "redirect-uris:" "${CONFIG_FILE}" || echo "âš ï¸ Section redirect-uris non trouvÃ©e"
                '''
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 2 : BUILD ET TESTS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸ” VÃ©rification Environnement') {
            steps {
                script {
                    echo 'â–¶ VÃ©rification de l\'environnement...'
                }

                sh '''
                    # Charger les secrets
                    . rhDemo/secrets/env-vars.sh

                    echo "Java version:"
                    java -version
                    echo ""
                    echo "Maven version:"
                    cd rhDemo && ./mvnw -version
                    echo ""
                    echo "Variables d'environnement:"
                    # Compter les variables RHDEMO sans afficher leurs valeurs (sÃ©curitÃ©)
                    RHDEMO_VAR_COUNT=$(env | grep -c "^RHDEMO_" || echo "0")
                    echo "âœ… $RHDEMO_VAR_COUNT variables RHDEMO configurÃ©es (valeurs masquÃ©es pour sÃ©curitÃ©)"
                '''
            }
        }

        stage('ğŸ—ï¸ Compilation Maven') {
            steps {
                script {
                    echo "â–¶ Compilation du projet Maven..."
                }

                dir('rhDemo') {
                    sh './mvnw clean compile -DskipTests'
                }
            }
        }

        stage('âœ… Tests Unitaires') {
            steps {
                script {
                    echo "â–¶ ExÃ©cution des tests unitaires..."
                }

                dir('rhDemo') {
                    sh './mvnw test'
                }
            }
            post {
                always {
                    junit 'rhDemo/target/surefire-reports/*.xml'
                }
            }
        }

        stage('ğŸ” Analyse OWASP Dependency-Check') {
            steps {
                script {
                    echo "â–¶ Analyse des vulnÃ©rabilitÃ©s des dÃ©pendances..."
                }

                dir('rhDemo') {
                    sh './mvnw org.owasp:dependency-check-maven:check'
                }
            }
            post {
                always {
                    // Archiver le rapport OWASP
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'rhDemo/target',
                        reportFiles: 'dependency-check-report.html',
                        reportName: 'OWASP Dependency-Check Report'
                    ])
                }
            }
        }

        stage('ğŸ“¦ Build Maven') {
            steps {
                script {
                    echo "â–¶ Build du projet (crÃ©ation du JAR)..."
                }

                dir('rhDemo') {
                    sh './mvnw package -DskipTests'
                }
            }
        }

        stage('ğŸ“Š Analyse SonarQube') {
            when {
                expression { params.RUN_SONAR == true }
            }
            steps {
                script {
                    echo "â–¶ Analyse de la qualitÃ© du code avec SonarQube..."
                }

                withSonarQubeEnv('SonarQube') {
                    dir('rhDemo') {
                        sh './mvnw sonar:sonar'
                    }
                }
            }
        }

        stage('ğŸš¦ Quality Gate SonarQube') {
            when {
                expression { params.RUN_SONAR == true }
            }
            steps {
                script {
                    echo "â–¶ Attente du rÃ©sultat Quality Gate..."
                }

                timeout(time: 10, unit: 'MINUTES') {
                    waitForQualityGate abortPipeline: true
                }
            }
        }

        stage('ğŸ“ˆ Couverture de Code') {
            steps {
                script {
                    echo 'â–¶ GÃ©nÃ©ration du rapport de couverture JaCoCo...'
                }

                dir('rhDemo') {
                    sh './mvnw jacoco:report'
                }

                jacoco(
                    execPattern: '**/rhDemo/target/jacoco.exec',
                    classPattern: '**/rhDemo/target/classes',
                    sourcePattern: '**/rhDemo/src/main/java'
                )
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 3 : DOCKER BUILD
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸ³ Build Image Docker') {
            steps {
                script {
                    echo "â–¶ Construction de l'image Docker avec Dockerfile (Eclipse Temurin 21)..."
                    echo "   Version dÃ©tectÃ©e: ${env.APP_VERSION}"
                    echo "   Image Ã  construire: ${env.RHDEMO_IMAGE}"
                    echo "âš ï¸  Nettoyage complet: suppression de toutes les images rhdemo-api existantes..."
                }

                // Supprimer TOUTES les anciennes images rhdemo-api pour forcer reconstruction et Ã©viter accumulation
                sh """
                    echo "ğŸ“Š Images rhdemo-api avant nettoyage:"
                    docker images rhdemo-api --format "table {{.Repository}}:{{.Tag}}\\t{{.Size}}\\t{{.CreatedAt}}" || true

                    echo ""
                    echo "ğŸ§¹ Suppression de toutes les images rhdemo-api..."
                    # Supprimer toutes les images avec le nom rhdemo-api (tous les tags)
                    docker images rhdemo-api -q | xargs -r docker rmi -f 2>/dev/null || echo "Aucune image rhdemo-api Ã  supprimer"

                    echo "âœ… Nettoyage terminÃ©"
                """

                dir('rhDemo') {
                    sh """
                        DOCKER_BUILDKIT=0 docker build -t ${env.RHDEMO_IMAGE} \
                                     -t rhdemo-api:latest \
                                     --build-arg BUILD_DATE=\$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                                     --build-arg VCS_REF=\$(git rev-parse --short HEAD) \
                                     --build-arg VERSION=${env.APP_VERSION} \
                                     .
                    """
                }

                script {
                    echo "âœ… Image Docker crÃ©Ã©e: ${env.RHDEMO_IMAGE}"

                    // Lister les images crÃ©Ã©es et afficher la taille
                    sh """
                        echo "ğŸ“Š Images crÃ©Ã©es:"
                        docker images rhdemo-api --format "table {{.Repository}}:{{.Tag}}\\t{{.Size}}\\t{{.CreatedAt}}"
                    """
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 4 : DÃ‰PLOIEMENT EPHEMERE DOCKER COMPOSE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('âš™ï¸ Configuration Environnement Test') {
            steps {
                script {
                    echo 'â–¶ Configuration de l\'environnement de test Docker Compose...'
                    echo '   Nettoyage des containers et volumes du build prÃ©cÃ©dent'
                }

                dir(env.EPHEMERE_INFRA_PATH) {
                    sh """
                        # ArrÃªter et supprimer les conteneurs du build prÃ©cÃ©dent via docker-compose
                        docker-compose -p ${env.COMPOSE_PROJECT_NAME} down -v 2>/dev/null || true

                        # Supprimer les containers avec noms fixes (peuvent rester d'un build prÃ©cÃ©dent avec KEEP_EPHEMERE_ENV)
                        echo "ğŸ§¹ Suppression des containers avec noms fixes..."
                        docker rm -f ${env.CONTAINER_NGINX} ${env.CONTAINER_APP} ${env.CONTAINER_DB} ${env.CONTAINER_KEYCLOAK} ${env.CONTAINER_KEYCLOAK_DB} 2>/dev/null || true

                        # Supprimer les volumes orphelins (crÃ©Ã©s par builds prÃ©cÃ©dents avec noms diffÃ©rents)
                        docker volume rm keycloak-ephemere-db-data rhdemo-ephemere-db-data rhdemo-ephemere-nginx-cache 2>/dev/null || true

                        # IMPORTANT: Supprimer l'image nginx locale pour forcer sa recrÃ©ation
                        # Ã‰vite les problÃ¨mes de layers corrompus oÃ¹ nginx.conf a Ã©tÃ© crÃ©Ã© comme rÃ©pertoire
                        echo "ğŸ§¹ Suppression image nginx pour Ã©viter layers corrompus..."
                        docker rmi ${env.NGINX_IMAGE} 2>/dev/null || true

                        # Nettoyer les rÃ©seaux orphelins
                        docker network prune -f

                        echo "âœ… Environnement nettoyÃ©"
                    """
                }
            }
        }

        stage('ğŸ” GÃ©nÃ©ration Certificats SSL') {
            steps {
                script {
                    echo 'â–¶ GÃ©nÃ©ration des certificats SSL auto-signÃ©s...'
                }

                dir(env.EPHEMERE_INFRA_PATH) {
                    sh """
                        ./generate-certs.sh --domain ${env.TEST_DOMAIN} --domain ${env.KEYCLOAK_DOMAIN}
                        echo "âœ… Certificats SSL gÃ©nÃ©rÃ©s"
                    """
                }
            }
        }

        stage('ğŸš€ DÃ©marrage Environnement Staging') {
            steps {
                script {
                    echo "â–¶ DÃ©marrage de l'environnement ephemere Docker Compose..."
                }

                dir(env.EPHEMERE_INFRA_PATH) {
                    sh """
                        # Source les secrets
                        set +x
                        . ../../secrets/env-vars.sh

                        # Exporter les variables d'environnement nÃ©cessaires pour docker-compose
                        # Mapping des noms de variables entre secrets et docker-compose
                        export RHDEMO_IMAGE=${env.RHDEMO_IMAGE}
                        export APP_VERSION=${env.APP_VERSION}-${env.BUILD_NUMBER}
                        export NGINX_IMAGE=${env.NGINX_IMAGE}
                        export POSTGRES_IMAGE=${env.POSTGRES_IMAGE}
                        export KEYCLOAK_IMAGE=${env.KEYCLOAK_IMAGE}
                        export RHDEMO_DB_PASSWORD=\${RHDEMO_DATASOURCE_PASSWORD_PG}
                        export KEYCLOAK_DB_PASSWORD=\${KEYCLOAK_DB_PASSWORD}
                        export KEYCLOAK_ADMIN=\${KEYCLOAK_ADMIN_USER}
                        export KEYCLOAK_ADMIN_PASSWORD=\${KEYCLOAK_ADMIN_PASSWORD}

                        set -x

                        # DÃ©marrer l'environnement (docker-compose crÃ©era automatiquement le rÃ©seau)
                        docker-compose -p ${env.COMPOSE_PROJECT_NAME} up -d

                        echo "âœ… Environnement ephemere dÃ©marrÃ©"
                    """
                }
            }
        }

        stage('ğŸ”— Connexion Jenkins au RÃ©seau Staging') {
            steps {
                script {
                    echo "â–¶ Connexion de Jenkins au rÃ©seau ephemere pour accÃ¨s direct aux services..."
                }

                sh """
                    # Trouver le conteneur Jenkins principal (pas l'agent)
                    JENKINS_CONTAINER=\$(docker ps --filter "name=jenkins" --format "{{.Names}}" | grep -v agent | head -n 1)
                    echo "ğŸ“¦ Conteneur Jenkins trouvÃ©: \$JENKINS_CONTAINER"

                    if [ -n "\$JENKINS_CONTAINER" ]; then
                        docker network connect ${env.NETWORK_EPHEMERE} \$JENKINS_CONTAINER 2>/dev/null || echo "âš ï¸  Jenkins dÃ©jÃ  connectÃ© au rÃ©seau"
                        echo "âœ… Jenkins (\$JENKINS_CONTAINER) connectÃ© au rÃ©seau ${env.NETWORK_EPHEMERE}"
                    else
                        echo "âŒ ERREUR: Conteneur Jenkins introuvable!"
                        docker ps --filter "name=jenkins"
                        exit 1
                    fi
                """
            }
        }

        stage('ğŸ“‹ Configuration Nginx HTTPS') {
            steps {
                script {
                    echo "â–¶ Copie des configurations Nginx et certificats SSL..."
                }

                dir(env.EPHEMERE_INFRA_PATH) {
                    sh """
                        echo "ğŸ“‹ Copie des configurations nginx..."
                        docker cp nginx/nginx.conf ${env.CONTAINER_NGINX}:/etc/nginx/nginx.conf
                        docker cp nginx/conf.d/. ${env.CONTAINER_NGINX}:/etc/nginx/conf.d/

                        if [ -d "certs" ]; then
                            docker cp certs/. ${env.CONTAINER_NGINX}:/etc/nginx/ssl/
                            echo "âœ… Configurations nginx et certificats copiÃ©s"
                        else
                            echo "âœ… Configurations nginx copiÃ©es (certificats manquants)"
                        fi

                        # Recharger la configuration nginx pour appliquer les changements
                        echo "ğŸ”„ Rechargement de la configuration nginx..."
                        docker exec ${env.CONTAINER_NGINX} nginx -t  # Test de la config
                        docker exec ${env.CONTAINER_NGINX} nginx -s reload  # Reload
                        echo "âœ… Nginx rechargÃ© avec la nouvelle configuration HTTPS"

                        # VÃ©rifier que nginx Ã©coute rÃ©ellement sur le port 443
                        echo "ğŸ” VÃ©rification que nginx Ã©coute sur le port 443..."
                        if docker exec ${env.CONTAINER_NGINX} netstat -tuln | grep -q ':443'; then
                            echo "âœ… Nginx Ã©coute sur le port 443 (HTTPS)"
                        else
                            echo "âŒ ERREUR: Nginx n'Ã©coute PAS sur le port 443!"
                            echo "Ports Ã©coutÃ©s par nginx:"
                            docker exec ${env.CONTAINER_NGINX} netstat -tuln
                            exit 1
                        fi
                    """
                }
            }
        }

        stage('â³ Attente Services Staging') {
            steps {
                script {
                    echo "â–¶ Attente du dÃ©marrage complet des services..."
                }

                sh """
                    echo "â–¶ Attente PostgreSQL..."
                    timeout 120 bash -c 'until docker exec ${env.CONTAINER_DB} pg_isready -U rhdemo > /dev/null 2>&1; do sleep 2; done'
                    echo "âœ“ PostgreSQL prÃªt"

                    echo "â–¶ Attente Keycloak DB..."
                    timeout 120 bash -c 'until docker exec ${env.CONTAINER_KEYCLOAK_DB} pg_isready -U keycloak > /dev/null 2>&1; do sleep 2; done'
                    echo "âœ“ Keycloak DB prÃªt"

                    echo "âœ… Bases de donnÃ©es prÃªtes"
                    echo "   Note: Le healthcheck Keycloak sera fait dans un stage dÃ©diÃ© ultÃ©rieur"
                """
            }
        }

        stage('ğŸ’¾ Initialisation Base de DonnÃ©es') {
            steps {
                script {
                    echo "â–¶ Initialisation de la base de donnÃ©es ephemere..."
                }

                dir(env.EPHEMERE_INFRA_PATH) {
                    sh '''
                        echo "â–¶ VÃ©rification des fichiers SQL..."
                        PGSCHEMA_PATH="../../pgschema.sql"
                        PGDATA_PATH="../../pgdata.sql"

                        if [ ! -f "$PGSCHEMA_PATH" ]; then
                            echo "âŒ Erreur: Fichier pgschema.sql introuvable Ã  $PGSCHEMA_PATH"
                            exit 1
                        fi

                        if [ ! -f "$PGDATA_PATH" ]; then
                            echo "âŒ Erreur: Fichier pgdata.sql introuvable Ã  $PGDATA_PATH"
                            exit 1
                        fi

                        echo "âœ“ Fichiers SQL trouvÃ©s"

                        echo "â–¶ Copie des fichiers SQL dans le container..."
                        docker cp "$PGSCHEMA_PATH" rhdemo-ephemere-db:/tmp/schema.sql
                        docker cp "$PGDATA_PATH" rhdemo-ephemere-db:/tmp/data.sql

                        echo "â–¶ ExÃ©cution du schÃ©ma SQL..."
                        docker exec rhdemo-ephemere-db psql -U rhdemo -d rhdemo -f /tmp/schema.sql

                        echo "â–¶ Insertion des donnÃ©es de test..."
                        docker exec rhdemo-ephemere-db psql -U rhdemo -d rhdemo -f /tmp/data.sql

                        echo "â–¶ VÃ©rification..."
                        EMPLOYEE_COUNT=$(docker exec rhdemo-ephemere-db psql -U rhdemo -d rhdemo -t -c "SELECT COUNT(*) FROM employes;" | tr -d ' ')

                        echo "âœ… Base de donnÃ©es initialisÃ©e"
                        echo "   ğŸ“Š Nombre d'employÃ©s: $EMPLOYEE_COUNT"

                        # VÃ©rifier qu'il y a des donnÃ©es (au moins 10 employÃ©s)
                        if [ "$EMPLOYEE_COUNT" -lt 10 ]; then
                            echo "âŒ Erreur: Trop peu d'employÃ©s insÃ©rÃ©s ($EMPLOYEE_COUNT < 10)"
                            exit 1
                        fi
                    '''
                }
            }
        }

        stage('ğŸ¥ Healthcheck Keycloak') {
            steps {
                script {
                    echo 'â–¶ Attente dÃ©marrage Keycloak...'
                    echo '   Test depuis Jenkins via le rÃ©seau Docker ephemere'

                    // Charger la bibliothÃ¨que
                    def lib = load 'rhDemo/vars/rhDemoLib.groovy'

                    // Healthcheck Keycloak depuis Jenkins (connectÃ© au rÃ©seau ephemere)
                    lib.waitForHealthcheck([
                        name: 'Keycloak',
                        url: "http://${env.CONTAINER_KEYCLOAK}:9000/health/ready",
                        timeout: 60,
                        initialWait: 45
                        // Pas de container: test depuis Jenkins, pas docker exec
                    ])
                }
            }
        }

        stage('ğŸ”‘ Initialisation Keycloak') {
            steps {
                script {
                    echo "â–¶ Initialisation du realm et des utilisateurs Keycloak..."
                    echo "   Jenkins est maintenant connectÃ© au rÃ©seau ephemere, keycloak-ephemere est rÃ©solvable"
                }

                dir(env.KEYCLOAK_INIT_PATH) {
                    sh '''
                        # ExÃ©cuter l'initialisation avec Maven
                        echo "â–¶ ExÃ©cution de rhDemoInitKeycloak..."
                        ../rhDemo/mvnw spring-boot:run -Dspring-boot.run.profiles=ephemere

                        echo "âœ… Keycloak initialisÃ© avec succÃ¨s"
                    '''
                }
            }
        }

        stage('ğŸ“‹ Copie Secrets vers Container App') {
            steps {
                script {
                    echo "â–¶ Copie du fichier de secrets dans le container applicatif..."
                }

                sh """
                    # CrÃ©er le rÃ©pertoire secrets dans le container
                    # Ces commandes fonctionnent mÃªme si le container est en restart loop
                    docker exec --user root ${env.CONTAINER_APP} mkdir -p /workspace/secrets
                    docker exec --user root ${env.CONTAINER_APP} chown spring:spring /workspace/secrets

                    # Copier le fichier de secrets
                    docker cp ${env.SECRETS_RHDEMO} ${env.CONTAINER_APP}:/workspace/secrets/secrets-rhdemo.yml

                    # DÃ©finir les permissions (user spring:spring)
                    docker exec --user root ${env.CONTAINER_APP} chown spring:spring /workspace/secrets/secrets-rhdemo.yml
                    docker exec --user root ${env.CONTAINER_APP} chmod 400 /workspace/secrets/secrets-rhdemo.yml

                    echo "âœ… Secrets copiÃ©s dans le container"
                """
            }
        }

        stage('ğŸ”„ RedÃ©marrage Application') {
            steps {
                script {
                    echo "â–¶ RedÃ©marrage du container applicatif pour charger les secrets..."
                }

                dir(env.EPHEMERE_INFRA_PATH) {
                    sh """
                        # RedÃ©marrer via docker-compose pour charger les secrets
                        docker-compose -p ${env.COMPOSE_PROJECT_NAME} restart rhdemo-app
                        echo "â³ Attente du redÃ©marrage (30s)..."
                        sleep 30
                    """
                }
            }
        }

        stage('ğŸ¥ Healthcheck Application RHDemo') {
            steps {
                script {
                    echo 'â–¶ VÃ©rification santÃ© de l\'application RHDemo...'
                    echo '   Test depuis Jenkins via le rÃ©seau Docker ephemere'

                    // Charger la bibliothÃ¨que
                    def lib = load 'rhDemo/vars/rhDemoLib.groovy'

                    // Healthcheck Application RHDemo depuis Jenkins (connectÃ© au rÃ©seau ephemere)
                    lib.waitForHealthcheck([
                        name: 'RHDemo App',
                        url: "http://${env.CONTAINER_APP}:9000/front/",
                        timeout: 90,
                        acceptedCodes: [200, 301, 302]
                        // Pas de container: test depuis Jenkins, pas docker exec
                    ])
                }
            }
        }

        stage('ğŸŒ Healthcheck Nginx HTTPS') {
            steps {
                script {
                    echo 'â–¶ VÃ©rification de l\'accÃ¨s HTTPS via nginx (test end-to-end)...'
                    echo '   Test depuis Jenkins via alias rÃ©seau Docker'

                    // Charger la bibliothÃ¨que
                    def lib = load 'rhDemo/vars/rhDemoLib.groovy'

                    // Healthcheck Nginx HTTPS avec certificat auto-signÃ©
                    // Utilise l'alias rÃ©seau Docker dÃ©fini dans docker-compose.yml
                    lib.waitForHealthcheck([
                        name: 'Nginx HTTPS',
                        url: "https://${env.TEST_DOMAIN}/front/",
                        timeout: 30,
                        acceptedCodes: [200, 302],
                        insecure: true
                    ])

                    echo 'âœ… Stack complÃ¨te opÃ©rationnelle et accessible via HTTPS'
                    echo '   PrÃªt pour les tests Selenium'
                }
            }
        }

        stage('ğŸ” Scan SÃ©curitÃ© Images Docker (Trivy)') {
            options {
                timeout(time: 8, unit: 'MINUTES')
            }
            steps {
                script {
                    echo "â–¶ Scan de sÃ©curitÃ© des images Docker avec Trivy (parallÃ©lisÃ©)..."
                    echo "   â„¹ï¸  Les 4 images seront scannÃ©es en parallÃ¨le pour optimiser le temps"
                    echo ""
                    echo "   âš ï¸  Le build Ã©chouera si vulnÃ©rabilitÃ©s CRITICAL dÃ©tectÃ©es"
                    echo "   â±ï¸  Timeout: 8 minutes (au lieu de 20 min sÃ©quentiel)"

                    // Charger la bibliothÃ¨que
                    def lib = load 'rhDemo/vars/rhDemoLib.groovy'

                    // CrÃ©er le rÃ©pertoire pour les rapports
                    sh 'mkdir -p trivy-reports'

                    // TÃ©lÃ©charger/mettre Ã  jour la base de donnÃ©es Trivy AVANT les scans parallÃ¨les
                    // La DB est tÃ©lÃ©chargÃ©e dans un cache partagÃ© qui sera copiÃ© pour chaque scan
                    // Ã‰vite les conflits d'accÃ¨s concurrent entre scans parallÃ¨les
                    echo "ğŸ“¥ TÃ©lÃ©chargement de la base de donnÃ©es Trivy dans le cache partagÃ©..."
                    sh '''
                        # CrÃ©er et utiliser le rÃ©pertoire de cache partagÃ©
                        TRIVY_CACHE_DIR="$(pwd)/.trivy-cache-shared"
                        mkdir -p "${TRIVY_CACHE_DIR}"
                        export TRIVY_CACHE_DIR

                        # TÃ©lÃ©charger la base de vulnÃ©rabilitÃ©s dans le cache partagÃ©
                        echo "ğŸ“¥ TÃ©lÃ©chargement de la base de vulnÃ©rabilitÃ©s..."
                        trivy image --download-db-only 2>&1 | grep -E "(Downloading|DB Repository)" || true

                        # TÃ©lÃ©charger la base Java DB (pour scanner rhdemo-app)
                        echo "ğŸ“¥ TÃ©lÃ©chargement de la Java DB..."
                        trivy image --download-java-db-only 2>&1 | grep -E "(Downloading|DB Repository)" || true

                        echo "âœ… Bases de donnÃ©es Trivy prÃªtes dans ${TRIVY_CACHE_DIR} (vuln + java)"
                        echo "   Chaque scan parallÃ¨le copiera ce cache pour Ã©viter les conflits d'accÃ¨s"
                    '''

                    // DÃ©finir les images Ã  scanner avec leurs noms de rapports
                    def imagesToScan = [
                        [image: env.POSTGRES_IMAGE, name: 'postgres'],
                        [image: env.KEYCLOAK_IMAGE, name: 'keycloak'],
                        [image: env.NGINX_IMAGE, name: 'nginx'],
                        [image: env.RHDEMO_IMAGE, name: 'rhdemo-app']
                    ]

                    echo "ğŸ“‹ Images Ã  scanner:"
                    imagesToScan.each { img ->
                        echo "   - ${img.name}: ${img.image}"
                    }

                    // CrÃ©er les stages parallÃ¨les de scan
                    def scanStages = imagesToScan.collectEntries { img ->
                        ["Scan ${img.name}": {
                            lib.generateTrivyReport(img.image, img.name)
                        }]
                    }

                    // ExÃ©cuter tous les scans en parallÃ¨le
                    parallel(scanStages + [failFast: false])

                    // AgrÃ©gation des rÃ©sultats et vÃ©rification des seuils
                    if (!lib.aggregateTrivyResults()) {
                        error("Trivy a dÃ©tectÃ© des vulnÃ©rabilitÃ©s CRITICAL bloquantes")
                    }
                }
            }
            post {
                always {
                    // Archiver tous les rapports Trivy
                    archiveArtifacts artifacts: 'trivy-reports/**/*', allowEmptyArchive: true

                    // Publier le rapport HTML agrÃ©gÃ©
                    publishHTML([
                        allowMissing: true,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'trivy-reports',
                        reportFiles: 'trivy-aggregate-report.html',
                        reportName: 'Trivy Security Scan Report'
                    ])
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 5 : TESTS SELENIUM ET OWASP ZAP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸ”’ DÃ©marrage OWASP ZAP Proxy') {
            when {
                expression { params.RUN_SELENIUM_TESTS == true }
            }
            steps {
                script {
                    echo 'â–¶ DÃ©marrage du proxy OWASP ZAP pour analyse de sÃ©curitÃ©...'
                    echo '   Le trafic Selenium sera interceptÃ© et analysÃ© par ZAP'
                }

                sh """#!/bin/bash
                    # Utiliser la clÃ© API ZAP dÃ©finie comme variable d'environnement Jenkins
                    echo "ğŸ” Utilisation de ZAP_API_KEY: ${env.ZAP_API_KEY.take(8)}..."

                    # IMPORTANT: ZAP est maintenant dans l'environnement Jenkins, pas ephemere
                    cd rhDemo/infra/jenkins-docker

                    # Nettoyage : supprimer le conteneur ZAP existant s'il existe
                    if docker ps -a --format '{{.Names}}' | grep -q '^rhdemo-jenkins-zap\$'; then
                        echo "ğŸ§¹ Suppression du conteneur ZAP existant..."
                        docker stop rhdemo-jenkins-zap 2>/dev/null || true
                        docker rm rhdemo-jenkins-zap 2>/dev/null || true
                        echo "âœ… Conteneur ZAP supprimÃ©"
                    fi

                    # DÃ©marrage d'un nouveau conteneur ZAP avec la clÃ© API correcte
                    echo "ğŸš€ DÃ©marrage d'un nouveau conteneur ZAP..."
                    echo "   RÃ©seau: rhdemo-jenkins-network"
                    echo "   ClÃ© API: ${env.ZAP_API_KEY.take(8)}..."
                    ZAP_API_KEY=${env.ZAP_API_KEY} docker-compose -f docker-compose.yml -f docker-compose.zap.yml up -d owasp-zap

                    echo "â³ Attente du dÃ©marrage de ZAP (60s max)..."
                    echo "   (ZAP doit charger ses add-ons, crÃ©er le certificat CA, etc.)"
                    timeout=60
                    attempt=0
                    while [ \$timeout -gt 0 ]; do
                        attempt=\$((attempt + 1))
                        if docker exec rhdemo-jenkins-zap curl -f http://localhost:8090/JSON/core/view/version/?apikey=${env.ZAP_API_KEY} >/dev/null 2>&1; then
                            echo "âœ… ZAP dÃ©marrÃ© et accessible (aprÃ¨s \$((60 - timeout))s)"
                            break
                        fi
                        if [ \$((attempt % 5)) -eq 0 ]; then
                            echo "   Attente... (\$((60 - timeout))s Ã©coulÃ©es, reste \${timeout}s)"
                        fi
                        sleep 2
                        timeout=\$((timeout - 2))
                    done

                    if [ \$timeout -le 0 ]; then
                        echo "âŒ Timeout: ZAP n'est pas prÃªt aprÃ¨s 60s"
                        echo "ğŸ“‹ Derniers logs de ZAP:"
                        docker logs --tail=50 rhdemo-jenkins-zap
                        exit 1
                    fi

                    echo "ğŸ“Š ZAP Status:"
                    docker exec rhdemo-jenkins-zap curl -s http://localhost:8090/JSON/core/view/version/?apikey=${env.ZAP_API_KEY} | jq .

                    echo ""
                    echo "ğŸ”— Connexion de ZAP au rÃ©seau ephemere..."
                    docker network connect rhdemo-ephemere-network rhdemo-jenkins-zap 2>/dev/null || echo "âš ï¸  ZAP dÃ©jÃ  connectÃ© au rÃ©seau ephemere"

                    echo ""
                    echo "âœ… OWASP ZAP prÃªt Ã  intercepter le trafic Selenium"
                    echo "   Container: rhdemo-jenkins-zap"
                    echo "   RÃ©seau 1: rhdemo-jenkins-network (API + Proxy)"
                    echo "   RÃ©seau 2: rhdemo-ephemere-network (accÃ¨s application via connexion dynamique)"
                    echo "   Port unique (API + Proxy): owasp-zap:8090"
                """
            }
        }

        stage('ğŸ§ª Tests Selenium') {
            when {
                expression { params.RUN_SELENIUM_TESTS == true }
            }
            steps {
                script {
                    echo "â–¶ ExÃ©cution des tests Selenium avec proxy ZAP..."
                }

                dir(env.TEST_PROJECT_PATH) {
                    sh """
                        # Source les secrets pour les tests
                        set +x
                        . ../rhDemo/secrets/env-vars.sh

                        # URLs via nginx avec HTTPS
                        # Depuis que nginx Ã©coute aussi sur le port 58443 en interne (rÃ©seau Docker),
                        # Selenium/ZAP peuvent utiliser directement les mÃªmes URLs que les utilisateurs externes:
                        # rhdemo.ephemere.local:58443 et keycloak.ephemere.local:58443
                        #
                        # Avantages:
                        # - URLs identiques pour tests et accÃ¨s manuel (cohÃ©rence)
                        # - Plus besoin de dÃ©tecter l'IP gateway
                        # - Redirect URIs OAuth2 simplifiÃ©s (pas d'IP Ã  whitelister)
                        # - RÃ©solution DNS stable via alias rÃ©seau Docker
                        #
                        # Note: ZAP est connectÃ© au rÃ©seau rhdemo-ephemere-network (ligne 1117),
                        # il peut donc rÃ©soudre les alias rÃ©seau et accÃ©der au port 58443 de nginx

                        APP_URL="https://rhdemo.ephemere.local:58443"
                        KEYCLOAK_URL="https://keycloak.ephemere.local:58443/realms/RHDemo"

                        # Credentials de test (user avec ROLE_consult + ROLE_MAJ pour tester toutes les opÃ©rations)
                        # Ces variables seront passÃ©es via propriÃ©tÃ©s Maven Ã  TestConfig
                        # Username chargÃ© depuis secrets-ephemere.yml (pas de valeur en dur)
                        TEST_USERNAME="\${RHDEMO_TEST_ID_USER_MAJ}"
                        TEST_PASSWORD="\${RHDEMO_TEST_PWD_USER_MAJ}"

                        # Configuration du proxy ZAP pour intercepter le trafic Selenium
                        # BaseSeleniumTest.java dÃ©tecte ces variables et configure le proxy WebDriver
                        export ZAP_PROXY_HOST=owasp-zap
                        export ZAP_PROXY_PORT=8090

                        echo "ğŸ“ Configuration des tests Selenium:"
                        echo "   APP_URL: \${APP_URL}"
                        echo "   KEYCLOAK_URL: \${KEYCLOAK_URL}"
                        echo "   TEST_USERNAME: \${TEST_USERNAME} (ROLE_consult + ROLE_MAJ)"
                        echo "   Mode: Headless"
                        echo "   ZAP Proxy: \${ZAP_PROXY_HOST}:\${ZAP_PROXY_PORT}"
                        echo "   (Healthcheck HTTPS validÃ© avant ce stage)"

                        set -x

                        # Lancement des tests avec TOUTES les configs via propriÃ©tÃ©s Maven
                        # TestConfig charge dans l'ordre: Maven properties > env vars > YAML
                        cd \${WORKSPACE}/rhDemo && ./mvnw clean test -f ../\${TEST_PROJECT_PATH}/pom.xml \\
                            -Dtest.baseurl=\${APP_URL} \\
                            -Dtest.keycloak.url=\${KEYCLOAK_URL} \\
                            -Dselenium.headless=true \\
                            -Dtest.username=\${TEST_USERNAME} \\
                            -Dtest.password=\${TEST_PASSWORD}
                    """
                }
            }
            post {
                failure {
                    script {
                        echo 'ğŸ“‹ Ã‰chec des tests Selenium - Collecte des logs des conteneurs...'

                        sh '''
                            # CrÃ©er le rÃ©pertoire pour les logs de debug
                            mkdir -p debug-logs

                            echo "ğŸ“ Collecte des logs Docker..."

                            # Logs de l'application Spring Boot (derniÃ¨res 500 lignes)
                            if docker ps --format '{{.Names}}' | grep -q "rhdemo-ephemere-app"; then
                                echo "  - Application Spring Boot..."
                                docker logs rhdemo-ephemere-app --tail 500 > debug-logs/app-springboot.log 2>&1
                            fi

                            # Logs Keycloak (derniÃ¨res 500 lignes)
                            if docker ps --format '{{.Names}}' | grep -q "keycloak-ephemere"; then
                                echo "  - Keycloak..."
                                docker logs keycloak-ephemere --tail 500 > debug-logs/keycloak.log 2>&1
                            fi

                            # Logs Nginx (derniÃ¨res 500 lignes)
                            if docker ps --format '{{.Names}}' | grep -q "rhdemo-ephemere-nginx"; then
                                echo "  - Nginx..."
                                docker logs rhdemo-ephemere-nginx --tail 500 > debug-logs/nginx.log 2>&1
                            fi

                            # Logs ZAP (derniÃ¨res 500 lignes)
                            if docker ps --format '{{.Names}}' | grep -q "rhdemo-jenkins-zap"; then
                                echo "  - OWASP ZAP..."
                                docker logs rhdemo-jenkins-zap --tail 500 > debug-logs/zap.log 2>&1
                            fi

                            # Informations rÃ©seau pour debug
                            echo "  - Configuration rÃ©seau Docker..."
                            docker network inspect rhdemo-ephemere-network > debug-logs/network-ephemere.json 2>&1 || echo "Network non trouvÃ©" > debug-logs/network-ephemere.json
                            docker network inspect rhdemo-jenkins-network > debug-logs/network-jenkins.json 2>&1 || echo "Network non trouvÃ©" > debug-logs/network-jenkins.json

                            # Ã‰tat des conteneurs
                            echo "  - Ã‰tat des conteneurs..."
                            docker ps -a --filter "name=ephemere" --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}" > debug-logs/containers-status.txt

                            echo "âœ… Logs collectÃ©s dans debug-logs/"
                            ls -lh debug-logs/
                        '''

                        // Archiver les logs de debug
                        archiveArtifacts artifacts: 'debug-logs/*', fingerprint: true, allowEmptyArchive: true
                    }
                }
                always {
                    script {
                        // Archiver les rapports de tests
                        junit allowEmptyResults: true, testResults: "${env.TEST_PROJECT_PATH}/target/surefire-reports/*.xml"

                        // Archiver les screenshots en cas d'Ã©chec
                        archiveArtifacts artifacts: "${env.TEST_PROJECT_PATH}/target/screenshots/**/*.png", allowEmptyArchive: true

                        // GÃ©nÃ©ration du rapport OWASP ZAP avant dÃ©connexion
                        echo 'ğŸ“Š GÃ©nÃ©ration du rapport OWASP ZAP...'
                        sh """#!/bin/bash
                            # Sauvegarder le workspace actuel
                            WORKSPACE_DIR=\$(pwd)

                            # CrÃ©er le rÃ©pertoire pour les rapports ZAP dans le workspace
                            mkdir -p "\${WORKSPACE_DIR}/zap-reports"

                            # Utiliser la clÃ© API ZAP dÃ©finie comme variable d'environnement Jenkins
                            ZAP_API_KEY="${env.ZAP_API_KEY}"
                            ZAP_HOST="owasp-zap"
                            ZAP_PORT="8090"

                            echo "ğŸ” RÃ©cupÃ©ration du rapport ZAP depuis http://\${ZAP_HOST}:\${ZAP_PORT}"
                            echo "   ClÃ© API utilisÃ©e: \${ZAP_API_KEY:0:8}..."

                            # Tester d'abord la connexion Ã  ZAP
                            if curl -s -f "http://\${ZAP_HOST}:\${ZAP_PORT}/JSON/core/view/version/?apikey=\${ZAP_API_KEY}" >/dev/null 2>&1; then
                                echo "âœ… Connexion Ã  ZAP rÃ©ussie"

                                # GÃ©nÃ©rer le rapport HTML
                                if curl -f -o "\${WORKSPACE_DIR}/zap-reports/zap-report.html" \
                                    "http://\${ZAP_HOST}:\${ZAP_PORT}/OTHER/core/other/htmlreport/?apikey=\${ZAP_API_KEY}" 2>&1; then
                                    echo "âœ… Rapport HTML ZAP gÃ©nÃ©rÃ©: \$(du -h \${WORKSPACE_DIR}/zap-reports/zap-report.html | cut -f1)"
                                else
                                    echo "âš ï¸  Ã‰chec de gÃ©nÃ©ration du rapport HTML ZAP"
                                fi

                                # GÃ©nÃ©rer Ã©galement le rapport JSON pour analyse
                                if curl -f -o "\${WORKSPACE_DIR}/zap-reports/zap-report.json" \
                                    "http://\${ZAP_HOST}:\${ZAP_PORT}/JSON/core/view/alerts/?apikey=\${ZAP_API_KEY}" 2>&1; then
                                    ALERT_COUNT=\$(jq '. | length' "\${WORKSPACE_DIR}/zap-reports/zap-report.json" 2>/dev/null || echo "?")
                                    echo "âœ… Rapport JSON ZAP gÃ©nÃ©rÃ©: \${ALERT_COUNT} alertes dÃ©tectÃ©es"
                                else
                                    echo "âš ï¸  Ã‰chec de gÃ©nÃ©ration du rapport JSON ZAP"
                                fi
                            else
                                echo "âŒ Impossible de se connecter Ã  ZAP - VÃ©rifier que ZAP est dÃ©marrÃ© et que la clÃ© API est correcte"
                            fi
                        """

                        // Archiver les rapports ZAP
                        archiveArtifacts artifacts: 'zap-reports/*', fingerprint: true, allowEmptyArchive: true

                        // DÃ©connexion de ZAP du rÃ©seau ephemere aprÃ¨s les tests
                        echo 'ğŸ”Œ DÃ©connexion de ZAP du rÃ©seau ephemere...'
                        sh '''
                            docker network disconnect rhdemo-ephemere-network rhdemo-jenkins-zap 2>/dev/null || echo "âš ï¸  ZAP dÃ©jÃ  dÃ©connectÃ© du rÃ©seau ephemere"
                            echo "âœ… ZAP dÃ©connectÃ© du rÃ©seau ephemere (reste sur jenkins-network)"
                        '''
                    }
                }
            }
        }

        stage('ğŸ“ GÃ©nÃ©ration Rapports') {
            steps {
                script {
                    echo 'â–¶ Publication des rapports HTML...'

                    // Charger la bibliothÃ¨que
                    def lib = load 'rhDemo/vars/rhDemoLib.groovy'

                    // DÃ©finir tous les rapports Ã  publier
                    def reports = [
                        ['rhDemo/target/site/jacoco', 'index.html', 'Code Coverage (JaCoCo)'],
                        ['trivy-reports', 'nginx.html', 'Trivy - Nginx'],
                        ['trivy-reports', 'postgres.html', 'Trivy - PostgreSQL'],
                        ['trivy-reports', 'keycloak.html', 'Trivy - Keycloak'],
                        ['trivy-reports', 'rhdemo-app.html', 'Trivy - RHDemo App'],
                        ['rhDemo/target', 'dependency-check-report.html', 'OWASP Dependency-Check'],
                        ['zap-reports', 'zap-report.html', 'OWASP ZAP Security Report']
                    ]

                    lib.publishHTMLReports(reports)
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 6 : PUBLICATION DE L'IMAGE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸ·ï¸ Tag et Publication Image') {
            when {
                expression { params.PUBLISH_IMAGE == true }
            }
            steps {
                script {
                    echo "â–¶ Tag et publication de l'image Docker sur le registry..."

                    // DÃ©terminer le tag final avec auto-incrÃ©mentation pour SNAPSHOT
                    def baseVersion = env.APP_VERSION
                    def finalTag

                    if (baseVersion.contains('SNAPSHOT')) {
                        // Pour les SNAPSHOT : ajouter le numÃ©ro de build pour garantir l'unicitÃ©
                        finalTag = "${baseVersion}-${env.BUILD_NUMBER}${params.IMAGE_TAG_SUFFIX}"
                        echo "   Mode SNAPSHOT dÃ©tectÃ© : ajout du build number"
                        echo "   Version Maven: ${baseVersion}"
                        echo "   Build number: ${env.BUILD_NUMBER}"
                    } else {
                        // Pour les releases : utiliser la version telle quelle
                        finalTag = "${baseVersion}${params.IMAGE_TAG_SUFFIX}"
                        echo "   Mode RELEASE"
                        echo "   Version Maven: ${baseVersion}"
                    }

                    env.FINAL_IMAGE_TAG = finalTag
                    echo "   Tag final: ${finalTag}"
                }

                sh """
                    # DÃ©tecter le nom du registry
                    REGISTRY_NAME=\$(docker ps --filter "publish=5000" --format '{{.Names}}' | head -n 1)

                    if [ -z "\$REGISTRY_NAME" ]; then
                        echo "âŒ Erreur: Aucun registry Docker trouvÃ© sur le port 5000"
                        exit 1
                    fi

                    echo "â–¶ Registry dÃ©tectÃ©: \$REGISTRY_NAME"

                    # Tag de l'image avec la version finale
                    echo "â–¶ Tag de l'image: ${env.DOCKER_IMAGE_NAME}:${env.FINAL_IMAGE_TAG}"
                    docker tag ${env.RHDEMO_IMAGE} ${env.DOCKER_IMAGE_NAME}:${env.FINAL_IMAGE_TAG}

                    # Tag pour le registry (utiliser localhost:5000 depuis Jenkins)
                    echo "â–¶ Tag pour le registry: localhost:5000/${env.DOCKER_IMAGE_NAME}:${env.FINAL_IMAGE_TAG}"
                    docker tag ${env.RHDEMO_IMAGE} localhost:5000/${env.DOCKER_IMAGE_NAME}:${env.FINAL_IMAGE_TAG}

                    # Push vers le registry
                    echo "â–¶ Push vers le registry..."
                    docker push localhost:5000/${env.DOCKER_IMAGE_NAME}:${env.FINAL_IMAGE_TAG}

                    # Tag latest
                    echo "â–¶ Tag latest..."
                    docker tag ${env.RHDEMO_IMAGE} localhost:5000/${env.DOCKER_IMAGE_NAME}:latest
                    docker push localhost:5000/${env.DOCKER_IMAGE_NAME}:latest

                    echo "âœ… Image publiÃ©e sur le registry:"
                    echo "   - localhost:5000/${env.DOCKER_IMAGE_NAME}:${env.FINAL_IMAGE_TAG}"
                    echo "   - localhost:5000/${env.DOCKER_IMAGE_NAME}:latest"
                """
            }
        }

        stage('ğŸ§¹ Nettoyage Registry SNAPSHOT') {
            when {
                allOf {
                    expression { params.PUBLISH_IMAGE == true }
                    expression { env.APP_VERSION.contains('SNAPSHOT') }
                }
            }
            steps {
                script {
                    echo "â–¶ Nettoyage des anciennes images SNAPSHOT du registry..."
                    echo "   Politique de rÃ©tention: garder les 3 derniÃ¨res versions"
                }

                sh """
                    REGISTRY_URL="http://localhost:5000"
                    IMAGE_NAME="${env.DOCKER_IMAGE_NAME}"
                    RETENTION_COUNT=3

                    echo "â–¶ RÃ©cupÃ©ration de la liste des tags SNAPSHOT..."

                    # RÃ©cupÃ©rer tous les tags de l'image
                    ALL_TAGS=\$(curl -s \${REGISTRY_URL}/v2/\${IMAGE_NAME}/tags/list | jq -r '.tags[]?' 2>/dev/null || echo "")

                    if [ -z "\$ALL_TAGS" ]; then
                        echo "â„¹ï¸  Aucun tag trouvÃ© dans le registry"
                        exit 0
                    fi

                    # Filtrer uniquement les tags SNAPSHOT avec numÃ©ro de build
                    SNAPSHOT_TAGS=\$(echo "\$ALL_TAGS" | grep "SNAPSHOT-[0-9]" | sort -V || true)

                    if [ -z "\$SNAPSHOT_TAGS" ]; then
                        echo "â„¹ï¸  Aucune image SNAPSHOT avec numÃ©ro de build trouvÃ©e"
                        exit 0
                    fi

                    # Compter le nombre de tags SNAPSHOT
                    TAG_COUNT=\$(echo "\$SNAPSHOT_TAGS" | wc -l)
                    echo "ğŸ“Š Nombre d'images SNAPSHOT trouvÃ©es: \$TAG_COUNT"

                    if [ "\$TAG_COUNT" -le "\$RETENTION_COUNT" ]; then
                        echo "âœ… Nombre d'images â‰¤ \$RETENTION_COUNT, aucun nettoyage nÃ©cessaire"
                        exit 0
                    fi

                    # Calculer combien d'images Ã  supprimer
                    TO_DELETE_COUNT=\$(( TAG_COUNT - RETENTION_COUNT ))
                    echo "ğŸ—‘ï¸  Suppression des \$TO_DELETE_COUNT images les plus anciennes..."

                    # Garder seulement les N derniers tags
                    TAGS_TO_DELETE=\$(echo "\$SNAPSHOT_TAGS" | head -n \$TO_DELETE_COUNT)

                    # Supprimer les anciennes images
                    for TAG in \$TAGS_TO_DELETE; do
                        echo "  â¤ Suppression de \${IMAGE_NAME}:\${TAG}..."

                        # RÃ©cupÃ©rer le manifest avec le bon Accept header pour obtenir le digest
                        DIGEST=\$(curl -sI -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \\
                            \${REGISTRY_URL}/v2/\${IMAGE_NAME}/manifests/\${TAG} \\
                            | grep -i "Docker-Content-Digest" \\
                            | awk '{print \$2}' \\
                            | tr -d '\\r')

                        if [ -n "\$DIGEST" ]; then
                            # Supprimer le manifest (cela marque l'image pour suppression)
                            HTTP_CODE=\$(curl -s -o /dev/null -w "%{http_code}" -X DELETE \\
                                \${REGISTRY_URL}/v2/\${IMAGE_NAME}/manifests/\${DIGEST})

                            if [ "\$HTTP_CODE" = "202" ] || [ "\$HTTP_CODE" = "204" ]; then
                                echo "    âœ“ Tag \${TAG} marquÃ© pour suppression (digest: \${DIGEST:0:20}...)"
                            else
                                echo "    âš ï¸  Ã‰chec suppression du tag \${TAG} (HTTP \$HTTP_CODE)"
                            fi
                        else
                            echo "    âš ï¸  Impossible de rÃ©cupÃ©rer le digest pour \${TAG}"
                        fi
                    done

                    echo ""
                    echo "âœ… Nettoyage des tags terminÃ©"
                    echo "ğŸ“‹ Images SNAPSHOT restantes:"
                    curl -s \${REGISTRY_URL}/v2/\${IMAGE_NAME}/tags/list | jq -r '.tags[]?' | grep "SNAPSHOT-[0-9]" | sort -V || echo "   (aucune)"

                    echo ""
                    echo "â–¶ ExÃ©cution du garbage collection du registry pour libÃ©rer l'espace disque..."

                    # Trouver le container du registry
                    REGISTRY_CONTAINER=\$(docker ps --filter "publish=5000" --format "{{.Names}}" | head -n 1)

                    if [ -z "\$REGISTRY_CONTAINER" ]; then
                        echo "âš ï¸  Container registry introuvable, garbage collection ignorÃ©"
                    else
                        echo "   Registry container: \$REGISTRY_CONTAINER"

                        # ExÃ©cuter le garbage collector en mode read-only d'abord pour voir ce qui serait supprimÃ©
                        echo "   Analyse des blobs Ã  supprimer..."
                        BLOBS_TO_DELETE=\$(docker exec \$REGISTRY_CONTAINER registry garbage-collect --dry-run /etc/docker/registry/config.yml 2>&1 | grep -c "would delete" || echo "0")

                        if [ "\$BLOBS_TO_DELETE" -gt 0 ]; then
                            echo "   ğŸ’¾ \$BLOBS_TO_DELETE blob(s) seront supprimÃ©s"

                            # ExÃ©cuter le garbage collector en mode suppression rÃ©elle
                            docker exec \$REGISTRY_CONTAINER registry garbage-collect /etc/docker/registry/config.yml

                            echo "   âœ… Garbage collection terminÃ©, espace disque libÃ©rÃ©"
                        else
                            echo "   â„¹ï¸  Aucun blob Ã  supprimer"
                        fi
                    fi

                    echo ""
                    echo "âœ… Nettoyage complet du registry terminÃ©"
                """
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 7 : ARCHIVAGE ET RAPPORTS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        stage('ğŸ“¦ Archivage Artifacts') {
            steps {
                script {
                    echo "â–¶ Archivage des artifacts..."
                }

                // Archiver le JAR
                archiveArtifacts artifacts: 'rhDemo/target/*.jar', fingerprint: true

                // Archiver les rapports de tests
                archiveArtifacts artifacts: 'rhDemo/target/surefire-reports/**', allowEmptyArchive: true

                // Archiver le rapport OWASP Dependency-Check
                archiveArtifacts artifacts: 'rhDemo/target/dependency-check-report.html', allowEmptyArchive: true
            }
        }

    } // fin stages

    post {
        always {
            script {
                // Charger la bibliothÃ¨que
                def lib = load 'rhDemo/vars/rhDemoLib.groovy'

                lib.printSectionHeader("Pipeline CI terminÃ©: ${currentBuild.currentResult}")

                // Nettoyage de l'environnement ephemere
                if (!params.KEEP_EPHEMERE_ENV) {
                    echo "ğŸ§¹ Nettoyage de l'environnement ephemere..."

                    // DÃ©connecter Jenkins du rÃ©seau ephemere
                    sh """
                        JENKINS_CONTAINER=\$(docker ps --filter "name=jenkins" --format "{{.Names}}" | grep -v agent | head -n 1)
                        if [ -n "\$JENKINS_CONTAINER" ]; then
                            docker network disconnect ${env.NETWORK_EPHEMERE} \$JENKINS_CONTAINER 2>/dev/null || echo "âš ï¸  Jenkins dÃ©jÃ  dÃ©connectÃ©"
                            echo "âœ… Jenkins dÃ©connectÃ© du rÃ©seau ephemere"
                        fi
                    """

                    // ArrÃªter et supprimer le container ZAP
                    echo "ğŸ§¹ Nettoyage du container OWASP ZAP..."
                    sh """
                        docker stop rhdemo-jenkins-zap 2>/dev/null || true
                        docker rm rhdemo-jenkins-zap 2>/dev/null || true
                        echo "âœ… Container ZAP supprimÃ©"
                    """

                    dir(env.EPHEMERE_INFRA_PATH) {
                        sh """
                            # ArrÃªter et supprimer l'environnement Docker Compose
                            docker-compose -p ${env.COMPOSE_PROJECT_NAME} down -v 2>/dev/null || true

                            # Supprimer les containers isolÃ©s
                            docker rm -f ${env.CONTAINER_NGINX} ${env.CONTAINER_APP} ${env.CONTAINER_DB} ${env.CONTAINER_KEYCLOAK} ${env.CONTAINER_KEYCLOAK_DB} 2>/dev/null || true

                            # Supprimer l'image de build temporaire
                            docker rmi ${env.RHDEMO_IMAGE} 2>/dev/null || true
                        """
                    }

                    echo "âœ… Nettoyage terminÃ©"
                } else {
                    echo "ğŸ”§ Mode DEBUG: Environnement ephemere prÃ©servÃ© pour tests manuels"
                    echo "âš ï¸  RAPPEL: L'environnement sera nettoyÃ© au prochain build"
                    echo "ğŸ“‹ Containers actifs: ${env.CONTAINER_NGINX}, ${env.CONTAINER_APP}, ${env.CONTAINER_DB}, ${env.CONTAINER_KEYCLOAK}"
                    echo "ğŸŒ URLs d'accÃ¨s:"
                    echo "   - RHDemo: https://rhdemo.ephemere.local"
                    echo "   - Keycloak: https://keycloak.ephemere.local"
                }

                // Supprimer les fichiers de secrets de maniÃ¨re sÃ©curisÃ©e
                lib.cleanupSecrets([
                    env.SECRETS_DECRYPTED,
                    env.SECRETS_ENV_VARS,
                    env.SECRETS_RHDEMO
                ])

                echo "âœ… Nettoyage terminÃ©"
            }
        }
        success {
            script {
                echo "âœ… Build rÃ©ussi !"
                if (params.PUBLISH_IMAGE) {
                    echo "ğŸ“¦ Image publiÃ©e: ${env.DOCKER_IMAGE_NAME}:${env.FINAL_IMAGE_TAG}"
                    echo "ğŸš€ PrÃªte pour le dÃ©ploiement CD"
                    echo ""
                    echo "Pour dÃ©ployer sur stagingkub, utilisez le pipeline Jenkinsfile-CD avec:"
                    echo "   IMAGE_TAG=${env.FINAL_IMAGE_TAG}"
                }
            }
        }
        failure {
            script {
                echo "âŒ Build Ã©chouÃ© !"
                echo "Consultez les logs pour plus de dÃ©tails."
            }
        }
    }
}
