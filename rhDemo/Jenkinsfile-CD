/*
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * Pipeline CD - RHDemo
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 *
 * Pipeline de D√©ploiement Continu (CD) pour l'application RHDemo
 *
 * OBJECTIF :
 *   - R√©cup√©rer une image Docker valid√©e depuis le registry
 *   - La d√©ployer sur l'environnement Kubernetes stagingkub
 *   - V√©rifier la sant√© de l'application d√©ploy√©e
 *
 * PR√â-REQUIS :
 *   - Image Docker publi√©e sur le registry par le pipeline CI (Jenkinsfile-CI)
 *   - Cluster KinD 'rhdemo' initialis√© (via init-stagingkub.sh)
 *   - Namespace 'rhdemo-staging' cr√©√©
 *
 * R√âSULTAT :
 *   - Application RHDemo d√©ploy√©e sur stagingkub
 *   - Services accessibles via Ingress
 *   - Health checks valid√©s
 *
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

pipeline {
    agent any

    options {
        timeout(time: 30, unit: 'MINUTES')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '50', artifactNumToKeepStr: '10'))
    }

    tools {
        jdk 'JDK21'
        maven 'Maven3'
    }

    environment {
        // Configuration application
        APP_NAME = 'rhdemo-api'
        DOCKER_IMAGE_NAME = "rhdemo-api"

        // Kubernetes
        K8S_NAMESPACE = 'rhdemo-staging'
        K8S_CONTEXT = 'kind-rhdemo'
        CLUSTER_NAME = 'rhdemo'

        // Fichiers de secrets SOPS
        SECRETS_FILE = 'rhDemo/secrets/secrets-staging.yml'
        SECRETS_DECRYPTED = 'rhDemo/secrets/secrets-decrypted.yml'
        SECRETS_ENV_VARS = 'rhDemo/secrets/env-vars.sh'
        SECRETS_RHDEMO = 'rhDemo/secrets/secrets-rhdemo.yml'

        // URLs
        APP_URL = 'https://rhdemo.staging.local'
        KEYCLOAK_URL = 'https://keycloak.staging.local'
    }

    parameters {
        string(
            name: 'IMAGE_TAG',
            defaultValue: '',
            description: 'Tag de l\'image √† d√©ployer (ex: 1.1.0-SNAPSHOT, 1.0.0-rc1). Si vide, utilisera la derni√®re version publi√©e.'
        )
        booleanParam(
            name: 'FORCE_RECREATE_PODS',
            defaultValue: false,
            description: 'Forcer la recr√©ation des pods (rollout restart)'
        )
        booleanParam(
            name: 'SKIP_HEALTH_CHECK',
            defaultValue: false,
            description: 'Ne pas attendre les health checks (d√©ploiement plus rapide mais moins s√ªr)'
        )
    }

    stages {

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 1 : PR√âPARATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        stage('üõ†Ô∏è Checkout') {
            steps {
                script {
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "  Pipeline CD - RHDemo"
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "Build: #${env.BUILD_NUMBER}"
                    echo "Branch: ${env.GIT_BRANCH ?: 'N/A'}"
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                }

                // Checkout du code
                checkout scm
            }
        }

        stage('üî¢ D√©terminer Version Image') {
            steps {
                script {
                    if (params.IMAGE_TAG) {
                        // Utiliser le tag fourni en param√®tre
                        env.DEPLOY_IMAGE_TAG = params.IMAGE_TAG
                        echo "‚ñ∂ Tag fourni en param√®tre: ${env.DEPLOY_IMAGE_TAG}"
                    } else {
                        // Lire la version depuis pom.xml via Maven
                        echo "‚ñ∂ Aucun tag fourni, lecture depuis pom.xml..."

                        dir('rhDemo') {
                            env.DEPLOY_IMAGE_TAG = sh(
                                script: './mvnw help:evaluate -Dexpression=project.version -q -DforceStdout',
                                returnStdout: true
                            ).trim()
                        }

                        if (!env.DEPLOY_IMAGE_TAG) {
                            error("‚ùå Impossible de d√©terminer la version de l'image")
                        }

                        echo "‚ñ∂ Version d√©tect√©e depuis pom.xml: ${env.DEPLOY_IMAGE_TAG}"
                    }

                    echo "‚úÖ Version de l'image √† d√©ployer: ${env.DEPLOY_IMAGE_TAG}"
                }
            }
        }

        stage('üîì D√©chiffrement Secrets SOPS') {
            steps {
                script {
                    echo '‚ñ∂ V√©rification SOPS et YQ...'
                }
                sh '''
                    sops --version
                    yq --version
                '''

                script {
                    echo '‚ñ∂ D√©chiffrement du fichier de secrets...'
                }

                // Utiliser le credential sops-age-key de mani√®re s√©curis√©e
                withCredentials([file(credentialsId: 'sops-age-key', variable: 'SOPS_AGE_KEY_FILE')]) {
                    sh '''
                        # Cr√©er le r√©pertoire secrets s'il n'existe pas
                        mkdir -p rhDemo/secrets

                        # D√©chiffrer le fichier de secrets
                        echo "D√©chiffrement de ${SECRETS_FILE}..."
                        sops -d ${SECRETS_FILE} > ${SECRETS_DECRYPTED}

                        # V√©rifier que le fichier a √©t√© d√©chiffr√©
                        if [ ! -f ${SECRETS_DECRYPTED} ]; then
                            echo "‚ùå √âchec du d√©chiffrement"
                            exit 1
                        fi

                        echo "‚úÖ Secrets d√©chiffr√©s avec succ√®s"

                        # Extraire les valeurs pour les variables d'environnement
                        # S√âCURIT√â: D√©sactiver l'√©cho des commandes pour ne pas exposer les secrets dans les logs
                        set +x

                        # Exporter les secrets comme variables d'environnement pour les stages suivants
                        {
                            # PROTECTION: D√©sactiver l'√©cho pour √©viter l'exposition des secrets lors du sourcing
                            echo "# S√âCURIT√â: Ce fichier contient des secrets - d√©sactive automatiquement le tracing bash"
                            echo "{ set +x; } 2>/dev/null"
                            echo ""

                            echo "export RHDEMO_DATASOURCE_PASSWORD_PG=$(yq eval '.rhdemo.datasource.password.pg' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_DATASOURCE_PASSWORD_H2=$(yq eval '.rhdemo.datasource.password.h2' ${SECRETS_DECRYPTED})"
                            echo "export RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET=$(yq eval '.rhdemo.client.registration.keycloak.client.secret' ${SECRETS_DECRYPTED})"

                            # Mots de passe Keycloak pour environnement staging
                            echo "export KEYCLOAK_DB_PASSWORD=$(yq eval '.keycloak.db.password' ${SECRETS_DECRYPTED})"
                            echo "export KEYCLOAK_ADMIN_PASSWORD=$(yq eval '.keycloak.admin.password' ${SECRETS_DECRYPTED})"
                            echo "export KEYCLOAK_ADMIN_USER=$(yq eval '.keycloak.admin.user // \"admin\"' ${SECRETS_DECRYPTED})"
                        } > rhDemo/secrets/env-vars.sh 2>&1

                        # R√©activer l'√©cho des commandes
                        set -x

                        echo "‚úÖ Variables d'environnement pr√©par√©es"
                    '''
                }
            }
            post {
                always {
                    script {
                        // Supprimer le fichier d√©chiffr√© pour la s√©curit√©
                        sh 'rm -f ${SECRETS_DECRYPTED} || true'
                    }
                }
            }
        }

        stage('üîê Extraction secrets rhDemo') {
            steps {
                script {
                    echo '‚ñ∂ Cr√©ation du fichier secrets-rhdemo.yml pour rhDemo...'
                }

                sh '''
                    # S√âCURIT√â: D√©sactiver l'√©cho des commandes
                    set +x

                    # Source les secrets
                    . rhDemo/secrets/env-vars.sh

                    # Cr√©er le fichier secrets-rhdemo.yml
                    cat > rhDemo/secrets/secrets-rhdemo.yml <<EOF

rhdemo:
  datasource:
    password:
      pg: ${RHDEMO_DATASOURCE_PASSWORD_PG}
      h2: ${RHDEMO_DATASOURCE_PASSWORD_H2}
  client:
    registration:
      keycloak:
        client:
          secret: ${RHDEMO_CLIENT_REGISTRATION_KEYCLOAK_CLIENT_SECRET}
EOF

                    # R√©activer l'√©cho
                    set -x

                    echo "‚úÖ Fichier secrets-rhdemo.yml cr√©√©"
                '''
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 2 : CONFIGURATION KUBERNETES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        stage('‚ò∏Ô∏è Configure Kubernetes Access') {
            steps {
                script {
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "  CONFIGURATION DE L'ACC√àS KUBERNETES"
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "‚ñ∂ Configuration de kubectl pour le cluster KinD..."
                }
                sh """
                    # V√©rifier que le cluster KinD existe
                    if ! kind get clusters | grep -q "^${env.CLUSTER_NAME}\$"; then
                        echo "‚ùå Cluster KinD '${env.CLUSTER_NAME}' non trouv√©"
                        echo "   Ex√©cutez d'abord: rhDemo/infra/stagingkub/scripts/init-stagingkub.sh"
                        exit 1
                    fi

                    echo "‚úÖ Cluster KinD '${env.CLUSTER_NAME}' trouv√©"

                    # Connecter Jenkins au r√©seau kind si n√©cessaire
                    JENKINS_CONTAINER=\$(hostname)
                    if ! docker network inspect kind 2>/dev/null | grep -q "\$JENKINS_CONTAINER"; then
                        echo "‚ñ∂ Connexion de Jenkins au r√©seau kind..."
                        docker network connect kind \$JENKINS_CONTAINER 2>/dev/null && echo "‚úÖ Jenkins connect√© au r√©seau kind" || echo "‚ö†Ô∏è  Impossible de connecter Jenkins au r√©seau kind"
                    else
                        echo "‚úÖ Jenkins d√©j√† connect√© au r√©seau kind"
                    fi

                    # G√©n√©rer une kubeconfig adapt√©e pour Jenkins
                    # Remplace l'adresse localhost par le nom DNS du container control-plane
                    echo "‚ñ∂ G√©n√©ration de la configuration kubectl..."
                    kind get kubeconfig --name ${env.CLUSTER_NAME} | sed 's|https://127.0.0.1:[0-9]*|https://rhdemo-control-plane:6443|g' > /tmp/kubeconfig-kind

                    # Installer la kubeconfig
                    mkdir -p \$HOME/.kube
                    cp /tmp/kubeconfig-kind \$HOME/.kube/config
                    chmod 600 \$HOME/.kube/config
                    rm /tmp/kubeconfig-kind

                    echo "‚úÖ Configuration kubectl install√©e"

                    # V√©rifier l'acc√®s au cluster
                    echo "‚ñ∂ V√©rification de l'acc√®s au cluster..."
                    if kubectl cluster-info 2>&1 | grep -q "is running"; then
                        echo "‚úÖ Acc√®s au cluster KinD confirm√©"
                        kubectl config use-context ${env.K8S_CONTEXT}
                        echo "‚úÖ Contexte '${env.K8S_CONTEXT}' activ√©"
                    else
                        echo "‚ùå Impossible d'acc√©der au cluster KinD"
                        echo "   Logs de d√©bogage:"
                        kubectl cluster-info || true
                        exit 1
                    fi
                """
            }
        }

        stage('üê≥ V√©rification Image Registry') {
            steps {
                script {
                    echo "‚ñ∂ V√©rification de l'image dans le registry..."
                }
                sh """
                    # D√©tection du registry sur le port 5000
                    REGISTRY_NAME=\$(docker ps --filter "publish=5000" --format '{{.Names}}' | head -n 1)

                    if [ -z "\$REGISTRY_NAME" ]; then
                        echo "‚ùå Aucun registry actif sur le port 5000"

                        # Chercher un registry existant (m√™me arr√™t√©)
                        EXISTING_REGISTRY=\$(docker ps -a --filter "publish=5000" --format '{{.Names}}' | head -n 1)

                        if [ -n "\$EXISTING_REGISTRY" ]; then
                            echo "‚ñ∂ Registry trouv√© mais arr√™t√©: \$EXISTING_REGISTRY"
                            echo "  D√©marrage du registry..."
                            docker start \$EXISTING_REGISTRY
                            REGISTRY_NAME="\$EXISTING_REGISTRY"
                            sleep 2
                        else
                            echo "‚ùå Aucun registry Docker trouv√©"
                            echo "   Cr√©ez d'abord un registry ou ex√©cutez le pipeline CI"
                            exit 1
                        fi
                    fi

                    echo "‚úÖ Registry d√©tect√©: \$REGISTRY_NAME"

                    # V√©rifier que l'image existe dans le registry
                    REGISTRY_URL="http://\$REGISTRY_NAME:5000"

                    echo "‚ñ∂ V√©rification de l'image ${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG}..."

                    if curl -sf \$REGISTRY_URL/v2/${env.DOCKER_IMAGE_NAME}/tags/list | grep -q "${env.DEPLOY_IMAGE_TAG}"; then
                        echo "‚úÖ Image trouv√©e dans le registry"
                    else
                        echo "‚ùå Image ${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG} introuvable dans le registry"
                        echo ""
                        echo "   Tags disponibles pour ${env.DOCKER_IMAGE_NAME}:"
                        curl -s \$REGISTRY_URL/v2/${env.DOCKER_IMAGE_NAME}/tags/list || echo "   Aucun tag trouv√©"
                        echo ""
                        echo "   Ex√©cutez d'abord le pipeline CI pour construire et publier l'image"
                        exit 1
                    fi
                """
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 3 : MISE √Ä JOUR DES SECRETS KUBERNETES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        stage('‚ò∏Ô∏è Update Kubernetes Secrets') {
            steps {
                script {
                    echo "‚ñ∂ Mise √† jour des secrets Kubernetes..."
                }
                sh """
                    # S√âCURIT√â: D√©sactiver l'√©cho des commandes pour ne pas exposer les secrets
                    set +x

                    # Charger les secrets depuis SOPS
                    . rhDemo/secrets/env-vars.sh

                    # Utiliser le contexte KinD
                    kubectl config use-context ${env.K8S_CONTEXT}

                    # Mettre √† jour les secrets Kubernetes
                    kubectl create secret generic rhdemo-db-secret \\
                      --from-literal=password="\${RHDEMO_DATASOURCE_PASSWORD_PG}" \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    kubectl create secret generic keycloak-db-secret \\
                      --from-literal=password="\${KEYCLOAK_DB_PASSWORD}" \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    kubectl create secret generic keycloak-admin-secret \\
                      --from-literal=password="\${KEYCLOAK_ADMIN_PASSWORD}" \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    # Mettre √† jour le secret pour secrets-rhdemo.yml
                    kubectl create secret generic rhdemo-app-secrets \\
                      --from-file=secrets-rhdemo.yml=rhDemo/secrets/secrets-rhdemo.yml \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --dry-run=client -o yaml | kubectl apply -f -

                    # R√©activer l'√©cho
                    set -x

                    echo "‚úÖ Secrets Kubernetes mis √† jour"
                """
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 4 : D√âPLOIEMENT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        stage('‚ò∏Ô∏è Deploy to Kubernetes') {
            steps {
                script {
                    def registryName = sh(script: 'docker ps --filter "publish=5000" --format "{{.Names}}" | head -n 1', returnStdout: true).trim()

                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "  D√âPLOIEMENT KUBERNETES (STAGINGKUB)"
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "‚ñ∂ D√©ploiement avec Helm..."
                    echo "   Chart: rhDemo/infra/stagingkub/helm/rhdemo"
                    echo "   Registry: ${registryName}"
                    echo "   Image: ${registryName}:5000/${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG}"
                    echo "   Namespace: ${env.K8S_NAMESPACE}"
                }
                sh """
                    # Utiliser le contexte KinD
                    kubectl config use-context ${env.K8S_CONTEXT}

                    # D√©ployer ou mettre √† jour avec Helm
                    # IMPORTANT: Utiliser le nom DNS du registry (d√©tect√© dynamiquement)
                    # Note: Le namespace doit d√©j√† exister (cr√©√© par init-stagingkub.sh)
                    helm upgrade --install rhdemo rhDemo/infra/stagingkub/helm/rhdemo \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --set rhdemo.image.repository=\$(docker ps --filter "publish=5000" --format '{{.Names}}' | head -n 1):5000/${env.DOCKER_IMAGE_NAME} \\
                      --set rhdemo.image.tag=${env.DEPLOY_IMAGE_TAG} \\
                      --wait \\
                      --timeout 10m

                    echo ""
                    echo "‚úÖ D√©ploiement Helm r√©ussi"
                """
            }
        }

        stage('üîÑ Force Pods Restart') {
            when {
                expression { params.FORCE_RECREATE_PODS == true }
            }
            steps {
                script {
                    echo "‚ñ∂ Red√©marrage forc√© des pods..."
                }
                sh """
                    kubectl config use-context ${env.K8S_CONTEXT}

                    # Rollout restart pour forcer le red√©marrage des pods
                    kubectl rollout restart deployment/rhdemo -n ${env.K8S_NAMESPACE} || true
                    kubectl rollout restart statefulset/postgresql-rhdemo -n ${env.K8S_NAMESPACE} || true
                    kubectl rollout restart statefulset/postgresql-keycloak -n ${env.K8S_NAMESPACE} || true
                    kubectl rollout restart deployment/keycloak -n ${env.K8S_NAMESPACE} || true

                    echo "‚úÖ Pods red√©marr√©s"
                """
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 5 : V√âRIFICATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        stage('‚ò∏Ô∏è Wait for Kubernetes Readiness') {
            when {
                expression { params.SKIP_HEALTH_CHECK == false }
            }
            steps {
                script {
                    echo "‚ñ∂ Attente de la disponibilit√© des services..."
                }
                sh """
                    kubectl config use-context ${env.K8S_CONTEXT}

                    # Attendre que tous les pods soient pr√™ts
                    echo "‚ñ∂ Attente des pods..."
                    kubectl wait --for=condition=ready pod --all \\
                      --namespace ${env.K8S_NAMESPACE} \\
                      --timeout=10m || {
                        echo "‚ö†Ô∏è  Certains pods ne sont pas pr√™ts apr√®s 10 minutes"
                        echo "   √âtat actuel des pods:"
                        kubectl get pods -n ${env.K8S_NAMESPACE}
                        echo ""
                        echo "   Logs des pods en erreur:"
                        kubectl get pods -n ${env.K8S_NAMESPACE} --field-selector=status.phase!=Running -o name | xargs -I {} kubectl logs {} -n ${env.K8S_NAMESPACE} --tail=50 || true
                        exit 1
                    }

                    echo "‚úÖ Tous les pods sont pr√™ts"
                """
            }
        }

        stage('üè• Health Checks') {
            when {
                expression { params.SKIP_HEALTH_CHECK == false }
            }
            steps {
                script {
                    echo "‚ñ∂ V√©rification de la sant√© des services..."
                }
                sh """
                    kubectl config use-context ${env.K8S_CONTEXT}

                    echo "‚ñ∂ V√©rification de l'application RHDemo..."
                    # R√©cup√©rer le nom du pod rhdemo (label app=rhdemo-app)
                    RHDEMO_POD=\$(kubectl get pods -n ${env.K8S_NAMESPACE} -l app=rhdemo-app -o jsonpath='{.items[0].metadata.name}')

                    if [ -z "\$RHDEMO_POD" ]; then
                        echo "‚ùå Aucun pod rhdemo trouv√©"
                        kubectl get pods -n ${env.K8S_NAMESPACE} --show-labels
                        exit 1
                    fi

                    echo "   Pod: \$RHDEMO_POD"

                    # V√©rifier l'actuator health
                    if kubectl exec \$RHDEMO_POD -n ${env.K8S_NAMESPACE} -- curl -sf http://localhost:9000/actuator/health > /dev/null 2>&1; then
                        echo "‚úÖ Application RHDemo : healthy"
                    else
                        echo "‚ùå Application RHDemo : unhealthy"
                        echo "   Logs du pod:"
                        kubectl logs \$RHDEMO_POD -n ${env.K8S_NAMESPACE} --tail=50
                        exit 1
                    fi

                    echo ""
                    echo "‚ñ∂ V√©rification de Keycloak..."
                    KEYCLOAK_POD=\$(kubectl get pods -n ${env.K8S_NAMESPACE} -l app=keycloak -o jsonpath='{.items[0].metadata.name}')

                    if [ -z "\$KEYCLOAK_POD" ]; then
                        echo "‚ö†Ô∏è  Aucun pod Keycloak trouv√©"
                    else
                        echo "   Pod: \$KEYCLOAK_POD"

                        if kubectl exec \$KEYCLOAK_POD -n ${env.K8S_NAMESPACE} -- curl -sf http://localhost:9000/health/ready > /dev/null 2>&1; then
                            echo "‚úÖ Keycloak : ready"
                        else
                            echo "‚ö†Ô∏è  Keycloak : not ready"
                            kubectl logs \$KEYCLOAK_POD -n ${env.K8S_NAMESPACE} --tail=30 || true
                        fi
                    fi

                    echo ""
                    echo "‚ñ∂ V√©rification de PostgreSQL RHDemo..."
                    PG_RHDEMO_POD=\$(kubectl get pods -n ${env.K8S_NAMESPACE} -l app=postgresql-rhdemo -o jsonpath='{.items[0].metadata.name}')

                    if [ -z "\$PG_RHDEMO_POD" ]; then
                        echo "‚ö†Ô∏è  Aucun pod PostgreSQL RHDemo trouv√©"
                    else
                        echo "   Pod: \$PG_RHDEMO_POD"

                        if kubectl exec \$PG_RHDEMO_POD -n ${env.K8S_NAMESPACE} -- pg_isready -U rhdemo > /dev/null 2>&1; then
                            echo "‚úÖ PostgreSQL RHDemo : ready"
                        else
                            echo "‚ö†Ô∏è  PostgreSQL RHDemo : not ready"
                        fi
                    fi

                    echo ""
                    echo "‚úÖ Health checks termin√©s"
                """
            }
        }

        stage('üìä Deployment Status') {
            steps {
                script {
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "  √âTAT DU D√âPLOIEMENT"
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                }
                sh """
                    kubectl config use-context ${env.K8S_CONTEXT}

                    echo "üìä Statut des pods:"
                    kubectl get pods -n ${env.K8S_NAMESPACE} -o wide

                    echo ""
                    echo "üîó Services:"
                    kubectl get svc -n ${env.K8S_NAMESPACE}

                    echo ""
                    echo "üåê Ingress:"
                    kubectl get ingress -n ${env.K8S_NAMESPACE}

                    echo ""
                    echo "üì¶ Images d√©ploy√©es:"
                    kubectl get pods -n ${env.K8S_NAMESPACE} -o jsonpath='{range .items[*]}{.metadata.name}{"\\t"}{.spec.containers[*].image}{"\\n"}{end}'

                    echo ""
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "‚úÖ D√âPLOIEMENT R√âUSSI"
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo ""
                    echo "üåç URLs d'acc√®s:"
                    echo "   Application: ${env.APP_URL}"
                    echo "   Keycloak: ${env.KEYCLOAK_URL}"
                    echo ""
                    echo "üìå Image d√©ploy√©e: ${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG}"
                    echo ""
                """
            }
        }

    } // fin stages

    post {
        always {
            script {
                echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                echo "Pipeline CD termin√©: ${currentBuild.currentResult}"
                echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

                // Supprimer les fichiers de secrets
                sh """
                    rm -f ${env.SECRETS_DECRYPTED} 2>/dev/null || true
                    rm -f ${env.SECRETS_ENV_VARS} 2>/dev/null || true
                    rm -f ${env.SECRETS_RHDEMO} 2>/dev/null || true
                """

                echo "‚úÖ Nettoyage termin√©"
            }
        }
        success {
            script {
                echo "‚úÖ D√©ploiement r√©ussi !"
                echo ""
                echo "üìå Image d√©ploy√©e: ${env.DOCKER_IMAGE_NAME}:${env.DEPLOY_IMAGE_TAG}"
                echo "üåç Application accessible: ${env.APP_URL}"
                echo "üîë Keycloak accessible: ${env.KEYCLOAK_URL}"
                echo ""
                echo "Pour v√©rifier l'√©tat:"
                echo "   kubectl get pods -n ${env.K8S_NAMESPACE}"
                echo "   kubectl logs -f deployment/rhdemo -n ${env.K8S_NAMESPACE}"
            }
        }
        failure {
            script {
                echo "‚ùå D√©ploiement √©chou√© !"
                echo "Consultez les logs pour plus de d√©tails:"
                echo "   kubectl get pods -n ${env.K8S_NAMESPACE}"
                echo "   kubectl describe pods -n ${env.K8S_NAMESPACE}"
                echo "   kubectl logs -n ${env.K8S_NAMESPACE} <pod-name>"
            }
        }
    }
}
